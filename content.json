{"meta":{"title":"Cyan","subtitle":null,"description":null,"author":"Qing","url":"https://summercat7.github.io"},"pages":[{"title":"关于我","date":"2019-07-17T16:06:15.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"about/index.html","permalink":"https://summercat7.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"大数据入门篇","slug":"大数据入门篇","date":"2023-05-22T12:51:14.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2023/05/22/大数据入门篇/","link":"","permalink":"https://summercat7.github.io/2023/05/22/大数据入门篇/","excerpt":"","text":"大数据入门篇ZooKeeper ZooKeeper主要服务于分布式系统，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。 使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够通用解决这些问题的中间件就应运而生了。 ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识。 那ZooKeeper这颗”树”有什么特点呢？？ZooKeeper的节点我们称之为Znode，Znode分为两种类型： 短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除 持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除 ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端) Zookeeper监听器ZooKeeper需要配合监听器才能够做那么多事的。 常见的监听场景有以下两项： 监听Znode节点的数据变化 监听子节点的增减变化 通过监听+Znode节点(持久/短暂[临时])，ZooKeeper就可以玩出这么多花样了。 Zookeeper 的使用场景统一配置管理比如我们现在有三个系统A、B、C，他们有三份配置，分别是ASystem.yml、BSystem.yml、CSystem.yml，然后，这三份配置又非常类似，很多的配置项几乎都一样。 此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息很可能就要重启系统 于是，我们希望把ASystem.yml、BSystem.yml、CSystem.yml相同的配置项抽取出来成一份公用的配置common.yml，并且即便common.yml改了，也不需要系统A、B、C重启。 做法：我们可以将common.yml这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，及时响应。 参考资料： 基于zookeeper实现统一配置管理 https://blog.csdn.net/u011320740/article/details/78742625 统一命名服务统一命名服务的理解其实跟域名一样，是我们为这某一部分的资源给它取一个名字，别人通过这个名字就可以拿到对应的资源。 比如说，现在我有一个域名www.java3y.com，但我这个域名下有多台机器： 192.168.1.1 192.168.1.2 192.168.1.3 192.168.1.4 别人访问www.java3y.com即可访问到我的机器，而不是通过IP去访问。 分布式锁我们可以使用ZooKeeper来实现分布式锁，那是怎么做的呢？？下面来看看： 系统A、B、C都去访问/locks节点 访问的时候会创建带顺序号的临时/短暂(EPHEMERAL_SEQUENTIAL)节点，比如，系统A创建了id_000000节点，系统B创建了id_000002节点，系统C创建了id_000001节点。 接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，判断自己创建的是不是最小的那个节点 如果是，则拿到锁。 释放锁：执行完操作后，把创建的节点给删掉 如果不是，则监听比自己要小1的节点变化 举个例子： 系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁 系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态 系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态 …… 等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁 ….系统B如上 集群状态经过上面几个例子，我相信大家也很容易想到ZooKeeper是怎么”感知“节点的动态新增或者删除的了。 还是以我们三个系统A、B、C为例，在ZooKeeper中创建临时节点即可： 只要系统A挂了，那/groupMember/A这个节点就会删除，通过监听groupMember下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理) 除了能够感知节点的上下线变化，ZooKeeper还可以实现动态选举Master的功能。(如果集群是主从架构模式下) 原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带顺序号的临时节点(EPHEMERAL_SEQUENTIAL)就好了。 Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让新的最小编号作为Master，这样就可以实现动态选举的功能了。 hdfs随着数据量越来越大，在一台机器上已经无法存储所有的数据了，那我们会将这些数据分配到不同的机器来进行存储，但是这就带来一个问题：不方便管理和维护 所以，我们就希望有一个系统可以将这些分布在不同操作服务器上的数据进行统一管理，这就有了分布式文件系统 HDFS是分布式文件系统的其中一种（目前用得最广泛的一种） 在使用HDFS的时候是非常简单的：虽然HDFS是将文件存储到不同的机器上，但是我去使用的时候是把这些文件当做是存储在一台机器的方式去使用（背后却是多台机器在执行）： 好比：我调用了一个RPC接口，我给他参数，他返回一个response给我。RPC接口做了什么事其实我都不知道的（可能这个RPC接口又调了其他的RPC接口）—–屏蔽掉实现细节，对用户友好 HDFS使用 明确一下：HDFS就是一个分布式文件系统，一个文件系统，我们用它来做什么？存数据呀。 Hdfs的读写过程一个用户发出了一个1GB的文件请求给HDFS客户端，HDFS客户端会根据配置(现在默认是128MB)，对这个文件进行切分，所以HDFS客户端会切分为8个文件(也叫做block)，然后每个服务器都会存储这些切分后的文件(block)。现在我们假设每个服务器都存储两份。 这些存放真实数据的服务器，在HDFS领域叫做DataNode HDFS客户端按照配置切分完以后，怎么知道往哪个服务器（DataNode）放数据呢？这个时候，就需要另一个角色了，管理者（NameNode）。 NameNode实际上就是管理文件的各种信息（这种信息专业点我们叫做MetaData「元数据」），其中包括：文文件路径名，每个Block的ID和存放的位置等等。 所以，无论是读还是写，HDFS客户端都会先去找NameNode，通过NameNode得知相应的信息，再去找DataNode 如果是写操作，HDFS切分完文件以后，会询问NameNode应该将这些切分好的block往哪几台DataNode上写。 如果是读操作，HDFS拿到文件名，也会去询问NameNode应该往哪几台DataNode上读数据。 hbaseApache HBase 是 Hadoop 数据库，一个分布式、可伸缩的大数据存储。 HBase是依赖Hadoop的。为什么HBase能存储海量的数据？因为HBase是在HDFS的基础之上构建的，HDFS是分布式文件系统。 为什么需要使用 HBase能够处理数据的中间件(系统)，这些中间件基本都会有持久化的功能。为什么？如果某一个时刻挂了，那还在内存但还没处理完的数据不就凉了？ Redis有AOF和RDB、Elasticsearch会把数据写到translog然后结合FileSystemCache将数据刷到磁盘中、Kafka本身就是将数据顺序写到磁盘…. 这些中间件会实现持久化（像HDFS和MySQL我们本身就用来存储数据的），为什么我们还要用HBase呢？ 虽然没有什么可比性，但是在学习的时候总会有一个疑问：「既然已学过的系统都有类似的功能了，那为啥我还要去学这个玩意？」 MySQL？MySQL数据库我们是算用得最多了的吧？但众所周知，MySQL是单机的。MySQL能存储多少数据，取决于那台服务器的硬盘大小。以现在互联网的数据量，很多时候MySQL是没法存储那么多数据的。 比如我这边有个系统，一天就能产生1TB的数据，这数据是不可能存MySQL的。（如此大的量数据，我们现在的做法是先写到Kafka，然后落到Hive中） Kafka？Kafka我们主要用来处理消息的（解耦异步削峰）。数据到Kafka，Kafka会将数据持久化到硬盘中，并且Kafka是分布式的（很方便的扩展），理论上Kafka可以存储很大的数据。但是Kafka的数据我们不会「单独」取出来。持久化了的数据，最常见的用法就是重新设置offset，做「回溯」操作 Redis？Redis是缓存数据库，所有的读写都在内存中，速度贼快。AOF/RDB存储的数据都会加载到内存中，Redis不适合存大量的数据（因为内存太贵了！）。 Elasticsearch？Elasticsearch是一个分布式的搜索引擎，主要用于检索。理论上Elasticsearch也是可以存储海量的数据（毕竟分布式），我们也可以将数据用『索引』来取出来，似乎已经是非常完美的中间件了。 但是如果我们的数据没有经常「检索」的需求，其实不必放到Elasticsearch，数据写入Elasticsearch需要分词，无疑会浪费资源。 HDFS？显然HDFS是可以存储海量的数据的，它就是为海量数据而生的。它也有明显的缺点：不支持随机修改，查询效率低，对小文件支持不友好。 文中的开头已经说了，HBase是基于HDFS分布式文件系统去构建的。换句话说，HBase的数据其实也是存储在HDFS上的。那肯定有好奇宝宝就会问：HDFS和HBase有啥区别阿？ HDFS是文件系统，而HBase是数据库，其实也没啥可比性。「你可以把HBase当做是MySQL，把HDFS当做是硬盘。HBase只是一个NoSQL数据库，把数据存在HDFS上」。 那我们为啥要用HBase呢？HBase在HDFS之上提供了高并发的随机写和支持实时查询，这是HDFS不具备的。HBase可以以低成本来存储海量的数据并且支持高并发随机写和实时查询。 HBase还有一个特点就是：存储数据的”结构“可以地非常灵活。 HBase 的Key-ValueHBase本质上其实就是Key-Value的数据库，上一次我们学Key-Value数据库还是Redis呢。那在HBase里边，Key是什么？Value是什么？ 下面是HBaseKey-Value结构图： Key由RowKey(行键)+ColumnFamily（列族）+Column Qualifier（列修饰符）+TimeStamp（时间戳–版本）+KeyType（类型）组成，而Value就是实际上的值。 对比上面的例子，其实很好理解，因为我们修改一条数据其实上是在原来的基础上增加一个版本的，那我们要准确定位一条数据，那就得（RowKey+Column+时间戳）。 KeyType是什么？我们上面只说了「修改」的情况，你们有没有想过，如果要删除一条数据怎么做？实际上也是增加一条记录，只不过我们在KeyType里边设置为“Delete”就可以了。 flink","categories":[{"name":"大数据","slug":"大数据","permalink":"https://summercat7.github.io/categories/大数据/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://summercat7.github.io/tags/大数据/"}],"keywords":[{"name":"大数据","slug":"大数据","permalink":"https://summercat7.github.io/categories/大数据/"}]},{"title":"IO与NIO的区别","slug":"IO与NIO的区别","date":"2020-12-23T08:49:13.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/12/23/IO与NIO的区别/","link":"","permalink":"https://summercat7.github.io/2020/12/23/IO与NIO的区别/","excerpt":"","text":"JAVA NIO vs IO Java NIO和IO的主要区别 IO NIO 面向Stream 面向Buffer 阻塞IO 非阻塞IO Selectors BIO网络模型： 1、面向流与面向缓冲 Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 2、阻塞与非阻塞IO Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 3、选择器（Selectors） Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 网络编程样例 1、BIO 服务端线程池 1234567891011121314151617181920212223242526import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class HandlerSocketServerPool &#123; // 用于存储socket线程的线程池 private ExecutorService executor; /** * public ThreadPoolExecutor(int corePoolSize, * int maximumPoolSize, * long keepAliveTime, * TimeUnit unit, * BlockingQueue&lt;Runnable&gt; workQueue) */ public HandlerSocketServerPool(int maxThreadNum, int queueSize) &#123; executor = new ThreadPoolExecutor(3, maxThreadNum, 120, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; // 提交任务到线程池队列里 public void execute(Runnable target) &#123; executor.execute(target); &#125;&#125; 服务端消息处理 123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.Socket;public class ServerRunnableTarget implements Runnable &#123; private Socket socket; public ServerRunnableTarget(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; // 处理接收到客服端socket通信请求 try &#123; // 1、从socket管道中获取一个字节输入流 InputStream is = socket.getInputStream(); // 2、把字节输入流包装成一个缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); String msg; while ((msg = br.readLine()) != null) &#123; System.out.println(\"服务端收到：\" + msg); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务端 1234567891011121314151617181920212223import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args) &#123; try &#123; // 1、注册接口 ServerSocket ss = new ServerSocket(9999); // 2、初始化线程池 HandlerSocketServerPool pool = new HandlerSocketServerPool(3,10); // 定义一个循环接收客服端Socket链接请求 while (true) &#123; Socket socket = ss.accept(); // 3、把socket对象提交给线程池 Runnable target = new ServerRunnableTarget(socket); pool.execute(target); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端 12345678910111213141516171819202122232425import java.io.IOException;import java.io.PrintStream;import java.net.Socket;import java.util.Scanner;public class Client &#123; public static void main(String[] args) &#123; try &#123; // 1、请求与服务端的Socket对象链接 Socket socket = new Socket(\"127.0.0.1\", 9999); // 2、得到一个打印流 PrintStream ps = new PrintStream(socket.getOutputStream()); // 3、使用循环不断的发送信息给服务端接收 Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(\"请输入发送内容：\"); String msg = sc.nextLine(); ps.println(msg); ps.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2、NIO 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;public class Server &#123; public static void main(String[] args) throws IOException &#123; // 1、获取通道 ServerSocketChannel ssChannel = ServerSocketChannel.open(); // 2、切换为非阻塞模式 ssChannel.configureBlocking(false); // 3、绑定连接的端口 ssChannel.bind(new InetSocketAddress(9999)); // 4、获取选择器Selector Selector selector = Selector.open(); // 5、将通道都注册到选择器上，并制定监听接收事件 ssChannel.register(selector, SelectionKey.OP_ACCEPT); // 6、使用Selector选择器轮询已经就绪好的事件 while (selector.select() &gt; 0 ) &#123; // 7、获取选择器中的所有注册的通道中就绪好的事件 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); // 8、开始遍历这些就绪好的事件 while (it.hasNext()) &#123; SelectionKey sk = it.next(); // 9、判断这个事件具体是什么 if (sk.isAcceptable()) &#123; // 10、直接获取当前接入的客户端通道 SocketChannel sChannel = ssChannel.accept(); // 11、切换为非阻塞模式 sChannel.configureBlocking(false); // 12、将本客服端通道注册到选择器中 sChannel.register(selector, SelectionKey.OP_READ); &#125; else if (sk.isReadable()) &#123; // 13、获取当前选择器上的读就绪事件 SocketChannel sChannel = (SocketChannel) sk.channel(); // 14、数据读取 ByteBuffer buffer = ByteBuffer.allocate(1024); int len; while ((len = sChannel.read(buffer)) &gt; 0) &#123; buffer.flip(); String string = new String(buffer.array(), 0, len); System.out.println(string); // 15、清除之前缓存区的数据 buffer.clear(); &#125; &#125; // 处理完毕之后需要移除当前事件 it.remove(); &#125; &#125; &#125;&#125; 客户端 1234567891011121314151617181920212223242526import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;import java.util.Scanner;public class Client &#123; public static void main(String[] args) throws IOException &#123; // 1、获取通道 SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\",9999)); // 2、设置为非阻塞模式 sChannel.configureBlocking(false); // 3、分配指定缓冲区大小 ByteBuffer buffer = ByteBuffer.allocate(1024); // 4、发送数据给服务器 Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(\"请输入发送内容：\"); String s = sc.nextLine(); buffer.clear(); buffer.put(s.getBytes()); buffer.flip(); sChannel.write(buffer); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring IOC 容器源码分析","slug":"Spring+IOC+容器源码分析","date":"2020-12-08T12:30:35.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/12/08/Spring+IOC+容器源码分析/","link":"","permalink":"https://summercat7.github.io/2020/12/08/Spring+IOC+容器源码分析/","excerpt":"","text":"Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。 本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。 阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。 希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。 引言先看下最基本的启动 Spring 容器的例子： 123public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");&#125; 以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。 多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。 废话说完，我们继续。ApplicationContext context = new ClassPathXmlApplicationContext(...) 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的： 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。 我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。 1、FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。 2、AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。 不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。 我们先来一个简单的例子来看看怎么实例化 ApplicationContext。 首先，定义一个接口： 123public interface MessageService &#123; String getMessage();&#125; 定义接口实现类： 123456public class MessageServiceImpl implements MessageService &#123; public String getMessage() &#123; return \"hello world\"; &#125;&#125; 接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/&gt;&lt;/beans&gt; 这样，我们就可以跑起来了： 12345678910111213public class App &#123; public static void main(String[] args) &#123; // 用我们的配置文件来启动一个 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\"); System.out.println(\"context 启动成功\"); // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // 这句将输出: hello world System.out.println(messageService.getMessage()); &#125;&#125; 以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。 BeanFactory 简介BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。 初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构： 我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。 ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。 ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。 然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。 启动过程分析下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。 第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。 1234567891011121314151617181920public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123; private Resource[] configResources; // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法 public ClassPathXmlApplicationContext(ApplicationContext parent) &#123; super(parent); &#125; ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割) setConfigLocations(configLocations); if (refresh) &#123; refresh(); // 核心方法 &#125; &#125; ...&#125; 接下来，就是 refresh()，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。 往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) &#123; // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try &#123; // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)， // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 下面，我们开始一步步来肢解这个 refresh() 方法。 创建 Bean 容器前的准备工作这个比较简单，直接看代码中的几个注释即可。 12345678910111213141516171819protected void prepareRefresh() &#123; // 记录启动时间， // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isInfoEnabled()) &#123; logger.info(\"Refreshing \" + this); &#125; // Initialize any placeholder property sources in the context environment initPropertySources(); // 校验 xml 配置文件 getEnvironment().validateRequiredProperties(); this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125; 创建 Bean 容器，加载并注册 Bean我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。 注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。 当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。 // AbstractApplicationContext.java 1234567891011protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等 refreshBeanFactory(); // 返回刚刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); &#125; return beanFactory;&#125; // AbstractRefreshableApplicationContext.java 120 1234567891011121314151617181920212223242526272829@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前 // ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。 DefaultListableBeanFactory beanFactory = createBeanFactory(); // 用于 BeanFactory 的序列化，我想不部分人应该都用不到 beanFactory.setSerializationId(getId()); // 下面这两个方法很重要，别跟丢了，具体细节之后说 // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用 customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125;&#125; 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。 我们说说为什么选择实例化 DefaultListableBeanFactory ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下： 我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？ 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。 那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。 在继续往下之前，我们需要先了解 BeanDefinition。我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？ 这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。 BeanDefinition 接口定义我们来看下 BeanDefinition 的接口定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123; // 我们可以看到，默认只提供 sington 和 prototype 两种， // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种， // 不过，它们属于基于 web 的扩展。 String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; // 比较不重要，直接跳过吧 int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍 // 一句话就是：继承父 Bean 的配置信息而已 void setParentName(String parentName); // 获取父 Bean String getParentName(); // 设置 Bean 的类名称，将来是要通过反射来生成实例的 void setBeanClassName(String beanClassName); // 获取 Bean 的类名称 String getBeanClassName(); // 设置 bean 的 scope void setScope(String scope); String getScope(); // 设置是否懒加载 void setLazyInit(boolean lazyInit); boolean isLazyInit(); // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)， // 是 depends-on=\"\" 属性设置的值。 void setDependsOn(String... dependsOn); // 返回该 Bean 的所有依赖 String[] getDependsOn(); // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效， // 如果根据名称注入，即使这边设置了 false，也是可以的 void setAutowireCandidate(boolean autowireCandidate); // 该 Bean 是否可以注入到其他 Bean 中 boolean isAutowireCandidate(); // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean void setPrimary(boolean primary); // 是否是 primary 的 boolean isPrimary(); // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录 // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的 void setFactoryBeanName(String factoryBeanName); // 获取工厂名称 String getFactoryBeanName(); // 指定工厂类中的 工厂方法名称 void setFactoryMethodName(String factoryMethodName); // 获取工厂类中的 工厂方法名称 String getFactoryMethodName(); // 构造器参数 ConstructorArgumentValues getConstructorArgumentValues(); // Bean 中的属性值，后面给 bean 注入属性值的时候会说到 MutablePropertyValues getPropertyValues(); // 是否 singleton boolean isSingleton(); // 是否 prototype boolean isPrototype(); // 如果这个 Bean 是被设置为 abstract，那么不能实例化， // 常用于作为 父bean 用于继承，其实也很少用...... boolean isAbstract(); int getRole(); String getDescription(); String getResourceDescription(); BeanDefinition getOriginatingBeanDefinition();&#125; 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。 有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分： 12customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory); 虽然只有两个方法，但路还很长啊。。。 customizeBeanFactorycustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; // 是否允许 Bean 定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; // 是否允许 Bean 间的循环依赖 beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。 至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。 之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。 加载 Bean: loadBeanDefinitions接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。 读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。 // AbstractXmlApplicationContext.java 80 123456789101112131415161718/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的， // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧 initBeanDefinitionReader(beanDefinitionReader); // 重点来了，继续往下 loadBeanDefinitions(beanDefinitionReader);&#125; 现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。 // AbstractXmlApplicationContext.java 120 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; // 往下看 reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; // 2 reader.loadBeanDefinitions(configLocations); &#125;&#125;// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123; Assert.notNull(resources, \"Resource array must not be null\"); int counter = 0; // 注意这里是个 for 循环，也就是每个文件是一个 resource for (Resource resource : resources) &#123; // 继续往下看 counter += loadBeanDefinitions(resource); &#125; // 最后返回 counter，表示总共加载了多少的 BeanDefinition return counter;&#125;// XmlBeanDefinitionReader 303@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125;// XmlBeanDefinitionReader 314public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; // 用一个 ThreadLocal 来存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 核心部分是这里，往下面看 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125;// 还在这个文件中，第 388 行protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; // 这里就不看了，将 xml 文件转换为 Document 对象 Document doc = doLoadDocument(inputSource, resource); // 继续 return registerBeanDefinitions(doc, resource); &#125; catch (...&#125;// 还在这个文件中，第 505 行// 返回值：返回从当前配置文件加载了多少数量的 Beanpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 这里 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125;// DefaultBeanDefinitionDocumentReader 90@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); // 从 xml 根节点开始解析文件 doRegisterBeanDefinitions(root);&#125; 经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析： doRegisterBeanDefinitions：123456789101112131415161718192021222324252627282930313233// DefaultBeanDefinitionDocumentReader 116protected void doRegisterBeanDefinitions(Element root) &#123; // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义， // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题， // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; // 这块说的是根节点 &lt;beans ... profile=\"dev\" /&gt; 中的 profile 是否是当前环境需要的， // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析 // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; preProcessXml(root); // 钩子 // 往下看 parseBeanDefinitions(root, this.delegate); postProcessXml(root); // 钩子 this.delegate = parent;&#125; preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。 这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。 接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) : 123456789101112131415161718192021222324// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，// 其他的属于 custom 的protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; // 解析 default namespace 下面的几个元素 parseDefaultElement(ele, delegate); &#125; else &#123; // 解析其他 namespace 的元素 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。 parseDefaultElement(ele, delegate) 代表解析的节点是 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt; 这几个。 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的： 12&gt; http://www.springframework.org/schema/beans&gt; 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。 1234567&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; xmlns=\"http://www.springframework.org/schema/beans\"&gt; xsi:schemaLocation=\"&gt; http://www.springframework.org/schema/beans&gt; http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; default-autowire=\"byName\"&gt;&gt; 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;等。 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。 假如读者想分析 &lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt; 的实现原理，就应该到 ContextNamespaceHandler 中找答案。 1234567891011121314&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; xmlns=\"http://www.springframework.org/schema/beans\"&gt; xmlns:context=\"http://www.springframework.org/schema/context\"&gt; xmlns:mvc=\"http://www.springframework.org/schema/mvc\"&gt; xsi:schemaLocation=\"&gt; http://www.springframework.org/schema/beans &gt; http://www.springframework.org/schema/beans/spring-beans.xsd&gt; http://www.springframework.org/schema/context&gt; http://www.springframework.org/schema/context/spring-context.xsd&gt; http://www.springframework.org/schema/mvc &gt; http://www.springframework.org/schema/mvc/spring-mvc.xsd &gt; \"&gt; default-autowire=\"byName\"&gt;&gt; 同理，以后你要是碰到 &lt;dubbo /&gt; 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。 回过神来，看看处理 default 标签的方法： 12345678910111213141516171819private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; // 处理 &lt;import /&gt; 标签 importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; // 处理 &lt;alias /&gt; 标签定义 // &lt;alias name=\"fromName\" alias=\"toName\"/&gt; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧 processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归 doRegisterBeanDefinitions(ele); &#125;&#125; 如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 &lt;bean /&gt; 标签出来说。 processBeanDefinition 解析 bean 标签下面是 processBeanDefinition 解析 &lt;bean /&gt; 标签： // DefaultBeanDefinitionDocumentReader 298 1234567891011121314151617181920protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的 if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 继续往下看怎么解析之前，我们先看下 &lt;bean /&gt; 标签中可以定义哪些属性： Property class 类的全限定名 name 可指定 id、name(用逗号、分号、空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autowiring mode no(默认值)、byName、byType、 constructor lazy-initialization mode 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。 简单地说就是像下面这样子： 123456789101112131415&lt;bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.javadoop.ExampleBean\" scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\"&gt; &lt;!-- 可以用下面三种形式指定构造参数 --&gt; &lt;constructor-arg type=\"int\" value=\"7500000\"/&gt; &lt;constructor-arg name=\"years\" value=\"7500000\"/&gt; &lt;constructor-arg index=\"0\" value=\"7500000\"/&gt; &lt;!-- property 的几种情况 --&gt; &lt;property name=\"beanOne\"&gt; &lt;ref bean=\"anotherExampleBean\"/&gt; &lt;/property&gt; &lt;property name=\"beanTwo\" ref=\"yetAnotherBean\"/&gt; &lt;property name=\"integerProperty\" value=\"1\"/&gt;&lt;/bean&gt; 当然，除了上面举例出来的这些，还有 factory-bean、factory-method、&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt; 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。 有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。 // BeanDefinitionParserDelegate 428 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null);&#125;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组， // 当然，如果你不定义 name 属性的话，就是空的了 // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了 if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; // 如果没有指定id, 那么用别名列表的第一个名字作为beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中, // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。 if (beanDefinition != null) &#123; // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生 // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; // 如果我们不定义 id 和 name，那么我们引言里的那个例子： // 1. beanName 为：com.javadoop.example.MessageServiceImpl#0 // 2. beanClassName 为：com.javadoop.example.MessageServiceImpl beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; // 把 beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 然后，我们再看看怎么根据配置创建 BeanDefinition 实例的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); /** * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素， * 解析出来以后的信息都放到 bd 的属性中 */ // 解析 &lt;meta /&gt; parseMetaElements(ele, bd); // 解析 &lt;lookup-method /&gt; parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;replaced-method /&gt; parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;constructor-arg /&gt; parseConstructorArgElements(ele, bd); // 解析 &lt;property /&gt; parsePropertyElements(ele, bd); // 解析 &lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(\"Bean class [\" + className + \"] not found\", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); &#125; catch (Throwable ex) &#123; error(\"Unexpected failure during bean definition parsing\", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 到这里，我们已经完成了根据 &lt;bean /&gt; 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。 我们回到解析 &lt;bean /&gt; 的入口方法: 123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 如果有自定义属性的话，进行相应的解析，先忽略 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 我们把这步叫做 注册Bean 吧 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // 注册完成后，发送事件，本文不展开说这个 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 &lt;bean /&gt; 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上： 12345678public class BeanDefinitionHolder implements BeanMetadataElement &#123; private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases;... 然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。 下面，我们开始说说注册 Bean 吧。 注册 Bean// BeanDefinitionReaderUtils 143 123456789101112131415161718public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; String beanName = definitionHolder.getBeanName(); // 注册这个 Bean registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了， // 获取的时候，会先将 alias 转换为 beanName，然后再查找 registry.registerAlias(beanName, alias); &#125; &#125;&#125; 别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。 // DefaultListableBeanFactory 793 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(...); &#125; &#125; // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding BeanDefinition oldBeanDefinition; // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中 oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 处理重复名称的 Bean 定义的情况 if (oldBeanDefinition != null) &#123; if (!isAllowBeanDefinitionOverriding()) &#123; // 如果不允许覆盖的话，抛异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()... &#125; else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // log...用框架定义的 Bean 覆盖用户自定义的 Bean &#125; else if (!beanDefinition.equals(oldBeanDefinition)) &#123; // log...用新的 Bean 覆盖旧的 Bean &#125; else &#123; // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean &#125; // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; // 判断是否已经有其他的 Bean 开始初始化了. // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程， // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // 最正常的应该是进到这个分支。 // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字 this.beanDefinitionNames.add(beanName); // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean， // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的 // 手动指的是通过调用以下方法注册的 bean ： // registerSingleton(String beanName, Object singletonObject) // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean， // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的 this.manualSingletonNames.remove(beanName); &#125; // 这个不重要，在预初始化的时候会用到，不必管它。 this.frozenBeanDefinitionNames = null; &#125; if (oldBeanDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125;&#125; 总结一下，到这里已经初始化了 Bean 容器，&lt;bean /&gt; 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。 ——— 分割线 ——— 到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。 Bean 容器实例化完成后说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。 考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) &#123; // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try &#123; // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说 // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成，不展开 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 准备 Bean 容器: prepareBeanFactory之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。 这里简单介绍下 prepareBeanFactory(factory) 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器， // 这里设置为加载当前 ApplicationContext 类的类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置 BeanExpressionResolver beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加一个 BeanPostProcessor，这个 processor 比较简单： // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware， // 还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们， // Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); /** * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值， * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。 * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean */ beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类， // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它 // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样， // 感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; /** * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean， * 我们也可以选择覆盖 */ // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。 初始化所有的 singleton beans我们的重点当然是 finishBeanFactoryInitialization(beanFactory); 这个巨头了，这里会负责初始化所有的 singleton beans。 注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。 我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 environment、systemProperties 等。 剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。 // AbstractApplicationContext.java 834 1234567891011121314151617181920212223242526272829303132333435363738394041// 初始化剩余的 singleton beansprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了 // 什么，看代码这里没有初始化 Bean 啊！ // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123; @Override public String resolveStringValue(String strVal) &#123; return getEnvironment().resolvePlaceholders(strVal); &#125; &#125;); &#125; // 先初始化 LoadTimeWeaverAware 类型的 Bean // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了， // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。 beanFactory.freezeConfiguration(); // 开始初始化 beanFactory.preInstantiateSingletons();&#125; 从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。 preInstantiateSingletons// DefaultListableBeanFactory 728 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overridepublic void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Pre-instantiating singletons in \" + this); &#125; // this.beanDefinitionNames 保存了所有的 beanNames List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作 for (String beanName : beanNames) &#123; // 合并父 Bean 中的配置，注意 &lt;bean id=\"\" class=\"\" parent=\"\" /&gt; 中的 parent，用的不多吧， // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解) if (isFactoryBean(beanName)) &#123; // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了 getBean(beanName); &#125; &#125; &#125; // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化 // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略 for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。 getBean在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。 // AbstractBeanFactory 196 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176@Overridepublic Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125;// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，// 已经初始化过了就从容器中直接返回，否则就先初始化再返回@SuppressWarnings(\"unchecked\")protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)， // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的 final String beanName = transformedBeanName(name); // 注意跟着这个，这个是返回值 Object bean; // 检查下是不是已经创建过了 Object sharedInstance = getSingleton(beanName); // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)， // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"...\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance， // 如果是 FactoryBean 的话，返回它创建的那个实例对象 // (FactoryBean 知识，读者若不清楚请移步附录) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; if (isPrototypeCurrentlyInCreation(beanName)) &#123; // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常， // 往往是因为陷入了循环引用 throw new BeanCurrentlyInCreationException(beanName); &#125; // 检查一下这个 BeanDefinition 在容器中是否存在 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有 String nameToLookup = originalBeanName(name); if (args != null) &#123; // 返回父容器的查询结果 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。 markBeanAsCreated(beanName); &#125; /* * 稍稍总结一下： * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean； * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。 */ try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先初始化依赖的所有 Bean，这个很好理解。 // 注意，这里的依赖指的是 depends-on 中定义的依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了 if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; // 注册一下依赖关系 registerDependentBean(dep, beanName); // 先初始化被依赖项 getBean(dep); &#125; &#125; // 如果是 singleton scope 的，创建 singleton 的实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; // 执行创建 Bean，详情后面再说 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 如果是 prototype scope 的，创建 prototype 的实例 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); // 执行创建 Bean prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; // 执行创建 Bean return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 大家应该也猜到了，接下来当然是分析 createBean 方法： 1protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException; 第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。 这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。 主要是为了以下场景，采用 @Autowired 注解注入属性值： 12345678public class MessageServiceImpl implements MessageService &#123; @Autowired private UserService userService; public String getMessage() &#123; return userService.getMessage(); &#125;&#125; 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。 好了，读者要知道这么回事就可以了，继续向前。 // AbstractAutowireCapableBeanFactory 447 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // 确保 BeanDefinition 中的 Class 被加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。 // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理， // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; // 重头戏，创建 bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125; 创建 Bean我们继续往里看 doCreateBean 这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\" final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 类型 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？ // 这里就是处理 bean 初始化完成后的各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; if (earlySingletonExposure) &#123; // Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject;&#125; 到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。 接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。 创建 Bean 实例我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // 确保已经加载了此 class Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // 校验一下这个类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); &#125; if (mbd.getFactoryMethodName() != null) &#123; // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // 如果不是第一次创建，比如第二次创建 prototype bean。 // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; // 构造函数依赖注入 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 无参构造函数 return instantiateBean(beanName, mbd); &#125; &#125; // 判断是否采用有参构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; // 构造函数依赖注入 return autowireConstructor(beanName, mbd, ctors, args); &#125; // 调用无参构造函数 return instantiateBean(beanName, mbd);&#125; 挑个简单的无参构造函数构造实例来看看： 123456789101112131415161718192021222324252627protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; try &#123; Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; return getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 实例化 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; // 包装一下，返回 BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); &#125;&#125; 我们可以看到，关键的地方在于： 1beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 这里会进行实际的实例化过程，我们进去看看: // SimpleInstantiationStrategy 59 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB, // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍 if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); &#125; &#125; &#125; // 利用构造方法进行实例化 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。 // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持 return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; 到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。 bean 属性注入看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。 // AbstractAutowireCapableBeanFactory 1203 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; // bean 实例的所有属性都在这里了 PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值， // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改， // 我也没找到有实际的使用，所以我们暂且忽略这块吧 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // 通过类型装配。复杂一些 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; // 设置 bean 实例的属性值 applyPropertyValues(beanName, mbd, bw, pvs);&#125; initializeBean属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。 1234567891011121314151617181920212223242526272829303132333435363738protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // BeanPostProcessor 的 postProcessBeforeInitialization 回调 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; // 处理 bean 中定义的 init-method， // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // BeanPostProcessor 的 postProcessAfterInitialization 回调 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？ 附录id 和 name每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。 我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。 1beanFactory.getBean(\"beanName or alias\"); 在配置 &lt;bean /&gt; 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。 1&lt;bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。 1&lt;bean name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。 1&lt;bean class=\"com.javadoop.example.MessageServiceImpl\"&gt; beanName 为：com.javadoop.example.MessageServiceImpl#0， 别名 1 个，为： com.javadoop.example.MessageServiceImpl 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，没有别名。 配置是否允许 Bean 覆盖、是否允许循环依赖我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。 循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。 它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。 添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。 123456789public class NoBeanOverridingContextLoader extends ContextLoader &#123; @Override protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123; super.customizeContext(servletContext, applicationContext); AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext; arac.setAllowBeanDefinitionOverriding(false); &#125;&#125; 12345678public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123; @Override protected ContextLoader createContextLoader() &#123; return new NoBeanOverridingContextLoader(); &#125; &#125; 123&lt;listener&gt; &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 如果以上方式不能满足你的需求，请参考这个链接：解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题 profile我们可以把不同环境的配置分别配置到单独的文件中，举个例子： 1234567891011&lt;beans profile=\"development\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xsi:schemaLocation=\"...\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 12345678&lt;beans profile=\"production\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt;&lt;/beans&gt; 应该不必做过多解释了吧，看每个文件第一行的 profile=””。 当然，我们也可以在一个配置文件中使用： 1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;beans profile=\"development\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=\"production\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt; &lt;/beans&gt;&lt;/beans&gt; 理解起来也很简单吧。 接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？ Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。 最简单的方式莫过于在程序启动的时候指定： 1-Dspring.profiles.active=\"profile1,profile2\" profile 可以激活多个 当然，我们也可以通过代码的形式从 Environment 中设置 profile： 1234AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(\"development\");ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh(); // 重启 如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile： 1java -Dspring.profiles.active=prod -jar JavaDoop.jar 如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。 工厂模式生成 Bean请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。 设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。 静态工厂： 123&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/&gt; 123456789public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; // 静态方法 public static ClientService createInstance() &#123; return clientService; &#125;&#125; 实例工厂： 1234567891011&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt;&lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; FactoryBeanFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。 12345public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;T&gt; getObjectType(); boolean isSingleton();&#125; 1234public class Person &#123; private Car car ; private void setCar(Car car)&#123; this.car = car; &#125; &#125; 我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来： 123456789101112131415161718192021public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123; private String make; private int year ; public void setMake(String m)&#123; this.make =m ; &#125; public void setYear(int y)&#123; this.year = y; &#125; public Car getObject()&#123; // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种 CarBuilder cb = CarBuilder.car(); if(year!=0) cb.setYear(this.year); if(StringUtils.hasText(this.make)) cb.setMake( this.make ); return cb.factory(); &#125; public Class&lt;Car&gt; getObjectType() &#123; return Car.class ; &#125; public boolean isSingleton() &#123; return false; &#125;&#125; 我们看看装配的时候是怎么配置的： 1234567&lt;bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\"&gt; &lt;property name = \"make\" value =\"Honda\"/&gt; &lt;property name = \"year\" value =\"1984\"/&gt;&lt;/bean&gt;&lt;bean class = \"com.javadoop.Person\" id = \"josh\"&gt; &lt;property name = \"car\" ref = \"car\"/&gt;&lt;/bean&gt; 看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。 说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？ 12345678910111213141516171819@Configuration public class CarConfiguration &#123; @Bean public MyCarFactoryBean carFactoryBean()&#123; MyCarFactoryBean cfb = new MyCarFactoryBean(); cfb.setMake(\"Honda\"); cfb.setYear(1984); return cfb; &#125; @Bean public Person aPerson()&#123; Person person = new Person(); // 注意这里的不同 person.setCar(carFactoryBean().getObject()); return person; &#125; &#125; 这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。 初始化 Bean 的回调有以下四种方案： 1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt; 123456public class AnotherExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 1234@Bean(initMethod = \"init\")public Foo foo() &#123; return new Foo();&#125; 1234@PostConstructpublic void init() &#123; &#125; 销毁 Bean 的回调1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/&gt; 123456public class AnotherExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 1234@Bean(destroyMethod = \"cleanup\")public Bar bar() &#123; return new Bar();&#125; 1234@PreDestroypublic void cleanup() &#123; &#125; ConversionService既然文中说到了这个，顺便提一下好了。 最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。 像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。 12345678&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.javadoop.learning.utils.StringToEnumConverterFactory\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。 下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。 来看一个很简单的例子，这样比什么都管用。 1234567891011public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; try &#123; return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\"); &#125; catch (ParseException e) &#123; return null; &#125; &#125;&#125; 只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。 Bean 继承在初始化 Bean 的地方，我们说过了这个： 1RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 这里涉及到的就是 &lt;bean parent=&quot;&quot; /&gt; 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。 首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。 Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean。 看如下一个例子: 12345678910&lt;bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\" parent=\"inheritedTestBean\" init-method=\"initialize\"&gt; &lt;property name=\"name\" value=\"override\"/&gt;&lt;/bean&gt; parent bean 设置了 abstract=&quot;true&quot; 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。 child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。 当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。 比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。 1234&lt;bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; 方法注入一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。 但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。 一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。 另一种解决方案就是这里要介绍的通过使用 Lookup method。 lookup-method我们来看一下 Spring Reference 中提供的一个例子： 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; xml 配置 &lt;lookup-method /&gt;： 123456789&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id=\"commandManager\" class=\"fiona.apple.CommandManager\"&gt; &lt;lookup-method name=\"createCommand\" bean=\"myCommand\"/&gt;&lt;/bean&gt; Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。 lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 &lt;lookup-method /&gt; 了，其他不变： 1234567891011public abstract class CommandManager &#123; public Object process(Object commandState) &#123; MyCommand command = createCommand(); command.setState(commandState); return command.execute(); &#125; @Lookup(\"myCommand\") protected abstract Command createCommand();&#125; 注意，既然用了注解，要配置注解扫描：&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt; 甚至，我们可以像下面这样： 1234567891011public abstract class CommandManager &#123; public Object process(Object commandState) &#123; MyCommand command = createCommand(); command.setState(commandState); return command.execute(); &#125; @Lookup protected abstract MyCommand createCommand();&#125; 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。 replaced-method记住它的功能，就是替换掉 bean 中的一些方法。 12345678public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125; 方法覆写，注意要实现 MethodReplacer 接口： 123456789public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 配置也很简单： 12345678&lt;bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\"&gt; &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt; &lt;replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/&gt; arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。 BeanPostProcessor应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义： 1234567public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。 首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。 我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。 那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。 最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？ 如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。 首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。 总结按理说，总结应该写在附录前面，我就不讲究了。 在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。 本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。 （全文完）","categories":[{"name":"Spring","slug":"Spring","permalink":"https://summercat7.github.io/categories/Spring/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"https://summercat7.github.io/categories/Spring/"}]},{"title":"sentinel实现对网关微服务管理","slug":"sentinel实现对网关微服务管理","date":"2020-12-04T06:48:20.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/12/04/sentinel实现对网关微服务管理/","link":"","permalink":"https://summercat7.github.io/2020/12/04/sentinel实现对网关微服务管理/","excerpt":"","text":"Sentinel 通过 nacos 对 Spring Cloud Gateway 持久化管理客户端使用时需引入以下模块（以 Maven 为例）：12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Sentinel扩展Nacos数据源的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 客户端配置文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778spring: cloud: # 读取向nacos注册的微服务 nacos: discovery: server-addr: 127.0.0.1:8848 # namespace: c0e306f9-a808-4b03-b40f-e9f2f2ded91c # sentinel 配置 sentinel: transport: dashboard: 127.0.0.1:8081 # 规则文件的nacos地址、命名空间、组名 nacos: server-addr: 127.0.0.1:8848 namespace: d3c1787a-4bd0-4d8b-98e6-6bf38672acfa groupId: SENTINEL_GROUP datasource: # 名称随意 gw-api-group: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-gw-api-group-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; # 规则类型，取值见： # org.springframework.cloud.alibaba.sentinel.datasource.RuleType rule-type: gw-api-group gw-flow: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-gw-flow-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; rule-type: gw-flow flow: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; dataId: $&#123;spring.application.name&#125;-flow-rules namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; # 规则类型，取值见： # org.springframework.cloud.alibaba.sentinel.datasource.RuleType rule-type: flow degrade: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-degrade-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; rule-type: degrade system: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-system-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; rule-type: system authority: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-authority-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; rule-type: authority param-flow: nacos: server-addr: $&#123;spring.cloud.sentinel.nacos.server-addr&#125; namespace: $&#123;spring.cloud.sentinel.nacos.namespace&#125; dataId: $&#123;spring.application.name&#125;-param-flow-rules groupId: $&#123;spring.cloud.sentinel.nacos.groupId&#125; rule-type: param-flow # 限流返回的响应 scg: fallback: mode: response response-status: 455 response-body: 服务器繁忙，请稍后再试！ eager: true Sentinel控制台改造：控制台改造主要是为规则实现 DynamicRuleProvider：从Nacos上读取配置 DynamicRulePublisher：将规则推送到Nacos上 1、修改pom.xml，找到将 test 这一行注释掉，即改为如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;/dependency&gt; 2、找到 sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule/nacos目录，将整个目录拷贝到 sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/rule/nacos 3、 修改 com.alibaba.csp.sentinel.dashboard.controller.v2.FlowControllerV2 ，修改为： 123456@Autowired@Qualifier(\"flowRuleNacosProvider\")private DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;@Autowired@Qualifier(\"flowRuleNacosPublisher\")private DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher; 4、 修改 sentinel-dashboard/src/main/webapp/resources/app/scripts/directives/sidebar/sidebar.html，解开注解： 1234&lt;li ui-sref-active=\"active\"&gt; &lt;a ui-sref=\"dashboard.flow(&#123;app: entry.app&#125;)\"&gt; &lt;i class=\"glyphicon glyphicon-filter\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;流控规则 V1&lt;/a&gt;&lt;/li&gt; 其他功能若要实现持久化，需要自己实现相关的DynamicRuleProvider和DynamicRulePublisher，相应代码已存本博客对应的文件夹中。本博客参考以下官方damo。 Spring Cloud Gateway从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流： route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId 自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组 使用时需引入以下模块（以 Maven 为例）： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt; &lt;version&gt;x.y.z&lt;/version&gt;&lt;/dependency&gt; 使用时只需注入对应的 SentinelGatewayFilter 实例以及 SentinelGatewayBlockExceptionHandler 实例即可。比如： 12345678910111213141516171819202122232425@Configurationpublic class GatewayConfiguration &#123; private final List&lt;ViewResolver&gt; viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) &#123; this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; &#125; @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() &#123; // Register the block exception handler for Spring Cloud Gateway. return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); &#125; @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public GlobalFilter sentinelGatewayFilter() &#123; return new SentinelGatewayFilter(); &#125;&#125; Demo 示例：sentinel-demo-spring-cloud-gateway 比如我们在 Spring Cloud Gateway 中配置了以下路由： 1234567891011121314151617181920212223server: port: 8090spring: application: name: spring-cloud-gateway cloud: gateway: enabled: true discovery: locator: lower-case-service-id: true routes: # Add your routes here. - id: product_route uri: lb://product predicates: - Path=/product/** - id: httpbin_route uri: https://httpbin.org predicates: - Path=/httpbin/** filters: - RewritePath=/httpbin/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; 同时自定义了一些 API 分组： 12345678910111213141516private void initCustomizedApis() &#123; Set&lt;ApiDefinition&gt; definitions = new HashSet&lt;&gt;(); ApiDefinition api1 = new ApiDefinition(\"some_customized_api\") .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123; add(new ApiPathPredicateItem().setPattern(\"/product/baz\")); add(new ApiPathPredicateItem().setPattern(\"/product/foo/**\") .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX)); &#125;&#125;); ApiDefinition api2 = new ApiDefinition(\"another_customized_api\") .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123; add(new ApiPathPredicateItem().setPattern(\"/ahas\")); &#125;&#125;); definitions.add(api1); definitions.add(api2); GatewayApiDefinitionManager.loadApiDefinitions(definitions);&#125; 那么这里面的 route ID（如 product_route）和 API name（如 some_customized_api）都会被标识为 Sentinel 的资源。比如访问网关的 URL 为 http://localhost:8090/product/foo/22 的时候，对应的统计会加到 product_route 和 some_customized_api 这两个资源上面，而 http://localhost:8090/httpbin/json 只会对应到 httpbin_route 资源上面。 您可以在 GatewayCallbackManager 注册回调进行定制： setBlockHandler：注册函数用于实现自定义的逻辑处理被限流的请求，对应接口为 BlockRequestHandler。默认实现为 DefaultBlockRequestHandler，当被限流时会返回类似于下面的错误信息：Blocked by Sentinel: FlowException。 客户端接入控制台控制台启动后，客户端需要按照以下步骤接入到控制台。 1 引入JAR包客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。您可以通过 pom.xml 引入 JAR 包: 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt; &lt;version&gt;x.y.z&lt;/version&gt;&lt;/dependency&gt; 2 配置启动参数启动时加入 JVM 参数 -Dcsp.sentinel.dashboard.server=consoleIp:port 指定控制台地址和端口。若启动多个应用，则需要通过 -Dcsp.sentinel.api.port=xxxx 指定客户端监控 API 的端口（默认是 8719）。 从 1.6.3 版本开始，控制台支持网关流控规则管理。您需要在接入端添加 -Dcsp.sentinel.app.type=1 启动参数以将您的服务标记为 API Gateway，在接入控制台时您的服务会自动注册为网关类型，然后您即可在控制台配置网关规则和 API 分组。 除了修改 JVM 参数，也可以通过配置文件取得同样的效果。更详细的信息可以参考 启动配置项。 API Gateway 适配Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。 Spring Cloud Gateway从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流： route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId 自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组 使用时需引入以下模块（以 Maven 为例）： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt; &lt;version&gt;x.y.z&lt;/version&gt;&lt;/dependency&gt; 使用时只需注入对应的 SentinelGatewayFilter 实例以及 SentinelGatewayBlockExceptionHandler 实例即可。比如： 12345678910111213141516171819202122232425@Configurationpublic class GatewayConfiguration &#123; private final List&lt;ViewResolver&gt; viewResolvers; private final ServerCodecConfigurer serverCodecConfigurer; public GatewayConfiguration(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) &#123; this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList); this.serverCodecConfigurer = serverCodecConfigurer; &#125; @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() &#123; // Register the block exception handler for Spring Cloud Gateway. return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer); &#125; @Bean @Order(-1) public GlobalFilter sentinelGatewayFilter() &#123; return new SentinelGatewayFilter(); &#125;&#125; Demo 示例：sentinel-demo-spring-cloud-gateway","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"nginx部署带项目名的vue项目","slug":"nginx部署带项目名的vue项目","date":"2020-10-14T08:53:35.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/10/14/nginx部署带项目名的vue项目/","link":"","permalink":"https://summercat7.github.io/2020/10/14/nginx部署带项目名的vue项目/","excerpt":"","text":"nginx部署带项目名的vue项目： 参考博客： https://blog.csdn.net/kielin/article/details/94459660 https://www.cnblogs.com/gaogch/p/10748114.html https://www.cnblogs.com/jedi1995/p/10900224.html","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"A*算法","slug":"A-算法","date":"2020-10-01T06:50:44.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/10/01/A-算法/","link":"","permalink":"https://summercat7.github.io/2020/10/01/A-算法/","excerpt":"","text":"A*算法 A*算法是一种启发式最小代价寻路算法 http://theory.stanford.edu/~amitp/GameProgramming/ 伪代码： 12345678910111213141516171819202122232425把起始格添加到 \"开启列表\" do &#123; 寻找开启列表中F值最低的格子, 我们称它为当前格. 把它切换到关闭列表. 对当前格相邻的8格中的每一个 if (它不可通过 || 已经在 \"关闭列表\" 中) &#123; 什么也不做. &#125; if (它不在开启列表中) &#123; 把它添加进 \"开启列表\", 把当前格作为这一格的父节点, 计算这一格的 FGH &#125; if (它已经在开启列表中) &#123; if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) &#123; 把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. &#125; &#125; 目标格已经在 \"开启列表\", 这时候路径被找到跳出循环；&#125; while(开启列表不为空) 如果开启列表已经空了,目标格没找到 说明路径不存在.最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;import java.util.Stack;public class AStarAlgorithm &#123; private static final int[][] DIREC = &#123;&#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;, &#123;1, 0&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;-1, -1&#125;&#125;; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(\"please enter (rows cols x1 y1 x2 y2): \"); final int rows = scanner.nextInt(); final int cols = scanner.nextInt(); int x1 = scanner.nextInt(); int y1 = scanner.nextInt(); int x2 = scanner.nextInt(); int y2 = scanner.nextInt(); scanner.close(); // generate a two-dimension array filled with 0 int map[][] = new int[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; int tmp[] = new int[cols]; Arrays.fill(tmp, 0); map[i] = tmp; &#125; int midr = rows / 2; int midc = cols / 2; /*map[midr - 1][midc] = 1; map[midr][midc] = 1; map[midr + 1][midc] = 1;*/ for (int i = 1; i &lt; rows - 1; i++) &#123; map[i][midc] = 1; &#125; map[2][6] = 1; map[3][6] = 1; map[4][6] = 1; map[5][6] = 1; findPath(map, x1, y1, x2, y2); &#125; private static void findPath(int[][] map, int x1, int y1, int x2, int y2) &#123; List&lt;Position&gt; openList = new ArrayList&lt;AStarAlgorithm.Position&gt;(); List&lt;Position&gt; closeList = new ArrayList&lt;AStarAlgorithm.Position&gt;(); boolean findFlag = false; Position termPos = null; // 起始点 Position startPos = new Position(x1, y1, calcH(x1, y1, x2, y2)); openList.add(startPos); do &#123; // 通过在开启列表中找到F值最小的点作为当前点 Position currentPos = openList.get(0); for (int i = 0; i &lt; openList.size(); i++) &#123; if (currentPos.F &gt; openList.get(i).F) &#123; currentPos = openList.get(i); &#125; &#125; // 将找到的当前点放到关闭列表中，并从开启列表中删除 closeList.add(currentPos); openList.remove(currentPos); //遍历当前点对应的8个相邻点 for (int i = 0; i &lt; DIREC.length; i++) &#123; int tmpX = currentPos.row + DIREC[i][0]; int tmpY = currentPos.col + DIREC[i][1]; if (tmpX &lt; 0 || tmpX &gt;= map.length || tmpY &lt; 0 || tmpY &gt;= map[0].length) &#123; continue; &#125; //创建对应的点 Position tmpPos = new Position(tmpX, tmpY, calcH(tmpX, tmpY, x2, y2), currentPos); //map中对应的格子中的值为1（障碍）， 或对应的点已经在关闭列表中 if (map[tmpX][tmpY] == 1 || closeList.contains(tmpPos)) &#123; continue; &#125; //如果不在开启列表中，则加入到开启列表 if (!openList.contains(tmpPos)) &#123; openList.add(tmpPos); &#125; else &#123; // 如果已经存在开启列表中，则用G值考察新的路径是否更好，如果该路径更好，则把父节点改成当前格并从新计算FGH Position prePos = null; for (Position pos : openList) &#123; if (pos.row == tmpX &amp;&amp; pos.col == tmpY) &#123; prePos = pos; break; &#125; &#125; if (tmpPos.G &lt; prePos.G) &#123; prePos.setFaPos(currentPos); &#125; &#125; &#125; // 判断终点是否在开启列表中 for (Position tpos : openList) &#123; if (tpos.row == x2 &amp;&amp; tpos.col == y2) &#123; termPos = tpos; findFlag = true; break; &#125; &#125; &#125; while(openList.size() != 0); if(!findFlag) &#123; System.out.println(\"no valid path!\"); return; &#125; Stack&lt;String&gt; resStack = new Stack&lt;String&gt;(); String pattern = \"(%d, %d)\"; if (termPos != null) &#123; resStack.push(String.format(pattern, termPos.row, termPos.col)); while(termPos.fa != null) &#123; termPos = termPos.fa; resStack.push(String.format(pattern, termPos.row, termPos.col)); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!resStack.empty()) &#123; sb.append(resStack.pop()); if (!resStack.empty()) &#123; sb.append(\" -&gt; \"); &#125; &#125; System.out.println(sb.toString()); &#125; /** * 计算某个格子的H值 * @param x * @param y * @param tx 终点的x值 * @param ty 终点的y值 * @return */ private static int calcH(int x, int y, int tx, int ty) &#123; int diff = Math.abs(x - tx) + Math.abs(y - ty); return diff * 10; &#125; static class Position &#123; public int F; public int G; public int H; public Position fa; public int row; public int col; public Position() &#123; &#125; public Position(int row, int col, int H) &#123; this(row, col, H, null); &#125; public Position(int row, int col, int H, Position pos) &#123; this.H = H; this.row = row; this.col = col; this.fa = pos; this.G = calcG(); this.F = G + H; &#125; /** * 计算某个点到起始点的代价G * @return */ private int calcG() &#123; if (fa == null) return 0; if (fa.row != this.row &amp;&amp; fa.col != this.col) &#123; return 14 + fa.G; &#125; return 10 + fa.G; &#125; public void setFaPos(Position pos) &#123; this.fa = pos; this.G = calcG(); this.F = G + H; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (!(obj instanceof Position)) &#123; return false; &#125; Position pos = (Position) obj; return this.row == pos.row &amp;&amp; this.col == pos.col; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + row; result = prime * result + col; return result; &#125; &#125;&#125; 参考博客： https://www.cnblogs.com/technology/archive/2011/05/26/2058842.html","categories":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}]},{"title":"凸包算法（分治）","slug":"凸包算法（分治）","date":"2020-10-01T03:15:57.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/10/01/凸包算法（分治）/","link":"","permalink":"https://summercat7.github.io/2020/10/01/凸包算法（分治）/","excerpt":"","text":"凸包问题–分治法获取能够完全包含平面上n个给定点的凸多边形。 一、分治法：（一）算法思路： （这里所说的直线都是有向直线的。） 将数组升序排序，若x轴坐标相同，按照y轴坐标升序排序。 最左边的点p1和最右边的点p_n一定是该集合凸包的顶点。该直线将点分为两个集合，上包为S1，下包为S2。在p1 p_n线上的点不可能是凸包的顶点，所以不用考虑。 在上包S1中，找到p_max(距离直线p1p_n最远距离的点)，若有两个距离同样远的点，取∠p_max p1 p_n最大的那个点（即△p_max p1 p_n面积最大）。 （一次递归到这里结束） 找出S1中所有在直线p1 p_max左边的点，这些点中一定有构成上包中左半部分边界的顶点，用上面的算法递归查找点，直到上包就是以p1和p_n为端点的线段。 下包S2中找下边界 同理。 *如何判断点是否在直线p1 p_max左边（同 p1 p_n上方）？ 如果q1（x1，y1），q2（x2，y2），q3（x3，y3）是平面上的任意三个点，那么三角形△q1 q2 q3的面积等于下面这个行列式绝对值的二分之一。当且仅当点q3=（x3，y3）位于直线q1 q2的左侧时，该表达式的符号为正，该点位于两个点确定的直线的左侧。 （二）源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258import java.util.ArrayList;import java.util.Arrays;/** * 凸包问题（分治法）： */public class ConvexHullProblem_DC &#123; boolean[] visit;// 标志点是否是凸包的顶点：1是，0不是 Point[] points;// 所有点 Point[] convexHullVertex;// 凸包的顶点 ArrayList&lt;Point&gt; convexHullList = new ArrayList&lt;&gt;();;// 凸包的顶点（顺序存放） public void ConvexHullProblem(Point[] points) &#123; this.points = points; quickSort(0, points.length - 1);// 升序排序 visit = new boolean[points.length]; recursion(0, points.length - 1);// 上包 recursion(points.length - 1, 0);// 下包 orderConvexHull(); &#125; /** * @title: recursion * @description: 在凸包的上包或下包中，找使△p_max p1 p_n面积最大的点p_max，并递归 * @param begin 直线的起点 * @param end 直线的终点 void */ void recursion(int begin, int end) &#123; // 直线的两端点为凸包的顶点 visit[begin] = true; visit[end] = true; if (begin &lt; end) &#123; boolean flag = false;// 标志直线左侧是否有点 int maxArea = 0;// 最大面积 int maxAreaindex = begin + 1;// 最大面积的点下标 for (int i = begin + 1; i &lt;= end - 1; i++) &#123;// begin和end已经是顶点，不需要判断 if (PointJudge(points[begin], points[end], points[i]) &gt; 0) &#123;// 点在直线左侧 // 找距离最远的点，因为底相同都是p1 pn，也就是求三角形面积最大的 flag = true; int area = PointCal(points[begin], points[end], points[i]); if (area &gt; maxArea) &#123; maxArea = area; maxAreaindex = i; &#125; else if (area == maxArea) &#123;// 若面积相同，取∠p_max p_begin p_end最大的那一个 System.out.println(22); double degreeA = Degree(points[begin], points[i], points[end]); double degreeB = Degree(points[begin], points[maxAreaindex], points[end]); if (degreeA &gt; degreeB) &#123; maxArea = area; maxAreaindex = i; &#125; &#125; &#125; &#125; // 若直线左侧还有点，则递归；没有点，则结束 if (flag == true) &#123; recursion(begin, maxAreaindex); recursion(maxAreaindex, end); &#125; &#125; else if (begin &gt; end) &#123; boolean flag = false; int maxArea = 0;// 最大面积 int maxAreaindex = end + 1;// 最大面积的点下标 for (int i = begin - 1; i &gt;= end + 1; i--) &#123;// 注意下包循环中的 起始点、终点、判断条件 if (PointJudge(points[begin], points[end], points[i]) &gt; 0) &#123;// 点在直线左侧 flag = true; int area = PointCal(points[begin], points[end], points[i]); if (area &gt; maxArea) &#123; maxArea = area; maxAreaindex = i; &#125; else if (area == maxArea) &#123;// 若面积相同，取∠p_max p_begin p_end最大的那一个 System.out.println(22); double degreeA = Degree(points[begin], points[i], points[end]); double degreeB = Degree(points[begin], points[maxAreaindex], points[end]); if (degreeA &gt; degreeB) &#123; maxArea = area; maxAreaindex = i; &#125; &#125; &#125; &#125; if (flag == true) &#123; recursion(begin, maxAreaindex); recursion(maxAreaindex, end); &#125; &#125; &#125; /** * @title: quickSort：运用Hoare * @description: 快速排序： 选取第一个元素作为基准点（可以随机选取），将剩下元素与基准点进行比较， * 比基准点大的放在右边，比基准点小的放在左边， 得到左子表和右子表，递归调用本函数； * @param points 数组 * @param begin 开始下标 * @param end 结束下标 * @throws: */ void quickSort(int begin, int end) &#123; if (begin &gt;= 0 &amp;&amp; begin &lt; end &amp;&amp; end &lt; points.length) &#123; int i = begin, j = end; Point center = points[i];// 中心元素 while (i != j) &#123; while (i &lt; j &amp;&amp; points[j].getX() &gt; center.getX()) &#123; j--; &#125; while (i &lt; j &amp;&amp; center.getX() == points[j].getX() &amp;&amp; points[j].getY() &gt; center.getY()) &#123; j--; &#125; /* * (i&lt;j)若points[j].getX()&lt; center.getX()或 center.getX() == * points[j].getX()且points[j].getY()&lt;center.getY() 以上两种情况，需要赋值 */ if (i &lt; j)// 跳出循环也有可能时因为i=j，所以这里要判断一下 points[i++] = points[j]; while (i &lt; j &amp;&amp; points[i].getX() &lt; center.getX()) &#123; i++; &#125; while (i &lt; j &amp;&amp; points[i].getX() == center.getX() &amp;&amp; points[i].getY() &lt; center.getY()) &#123; i++; &#125; /* * (i&lt;j)若points[i].getX()&gt; center.getX()或 center.getX() == * points[i].getX()且points[i].getY()&gt;center.getY() 以上两种情况，需要赋值 */ if (i &lt; j) points[j--] = points[i]; &#125; points[i] = center;// 中心元素到达最终位置 quickSort(begin, i - 1); quickSort(i + 1, end); &#125; &#125; /** * @title: PointCal * @description: 计算行列式的值 * @param beginP 直线的开始点 * @param p 判断的点 * @param endP 直线的终点 * @return int 行列书的值 */ private int PointCal(Point beginP, Point endP, Point p) &#123; int cal = 0;// 行列式值//x1y2+x3y1+x2y3-x3y2-x2y1-x1y3 cal = beginP.getX() * endP.getY() + p.getX() * beginP.getY() + endP.getX() * p.getY() - p.getX() * endP.getY() - endP.getX() * beginP.getY() - beginP.getX() * p.getY(); return cal; &#125; /** * @title: PointJudge * @description:返回点p在直线beginP endP的位置 * @param beginP * @param p 判断的点 * @param endP * @return int ：1在直线左侧，0在线上，-1在右侧 * @throws: 注意传参放在第几个，前两个点是直线的两端，第三个是需要判断的点 */ private int PointJudge(Point beginP, Point endP, Point p) &#123; if (PointCal(beginP, endP, p) &gt; 0) &#123; return 1; &#125; else if (PointCal(beginP, endP, p) == 0) return 0; else return -1; &#125; /** * @title: Degree * @description: 余弦公式求∠pa pb pc的度数 * @param pa 点 * @param pb * @param pc * @return double：返回∠c的度数（°为单位） * @throws: */ double Degree(Point pa, Point pb, Point pc) &#123; double degree = 0;// ∠pa pb pc度数 // 三角形的三边长 double a = Math.sqrt(Math.pow(pa.getX() - pb.getX(), 2) + Math.pow(pa.getY() - pb.getY(), 2)); double b = Math.sqrt(Math.pow(pb.getX() - pc.getX(), 2) + Math.pow(pb.getY() - pc.getY(), 2)); double c = Math.sqrt(Math.pow(pc.getX() - pa.getX(), 2) + Math.pow(pc.getY() - pa.getY(), 2)); // 余弦公式求∠pa pb pc度数 System.out.println(\"acos=\" + Math.acos((a * a + b * b - c * c) / (2.0 * a * b))); degree = Math.toDegrees(Math.acos((a * a + b * b - c * c) / (2.0 * a * b))); System.out.println(\"degree=\" + degree); return degree; &#125; /** *@title: orderConvexHull *@description: 凸包顶点按顺时针输出 */ void orderConvexHull() &#123; /** 将凸包顶点存放进另一个数组 */ int count = 0;// 凸包的顶点个数 for (int i = 0; i &lt; visit.length; i++) &#123; if (visit[i] == true) &#123; count++; &#125; &#125; convexHullVertex = new Point[count]; for (int j = 0, i = 0; j &lt; visit.length; j++) &#123; if (visit[j] == true) &#123; convexHullVertex[i] = points[j]; i++; &#125; &#125; convexHullList.add(convexHullVertex[0]);// 开始点 int haveCount = 1;// 已经加入点的个数 // 逐条确定边界，判断是否除了该条假设边界上的点，其他凸包的顶点都在直线的右边。 // 如果是，则此条直线为边界；如果不是，取下一个边界终点，继续判断。 int start = 0;// 起点 for (int end = start + 1; haveCount &lt; count;) &#123; boolean boundRight = true; for (int i = 0; i &lt; count; i++) &#123; while (i &lt; count &amp;&amp; (i == start || i == end)) &#123;// 不能写if，start和end可能是连在一起的 i++; &#125; if (i &gt;= count) break; // 点在直线左侧或线上，错误 if (PointJudge(convexHullVertex[start], convexHullVertex[end], convexHullVertex[i]) &gt;= 0) &#123; boundRight = false; end = (end + 1) % count;// end取下一个 break; &#125; &#125; if (boundRight == true) &#123; convexHullList.add(convexHullVertex[end]); start = end; end = (start + 1) % count; haveCount++; &#125; &#125; convexHullList.add(convexHullVertex[0]);// 结束点 System.out.println(\"凸包顶点顺时针输出：\" + convexHullList); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** * 点的信息 */public class Point &#123; private int x, y;// 横纵坐标 public Point(int x,int y) &#123; this.x=x; this.y=y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public String toString() &#123; return \" (\" + x + \", \"+ y + \")\"; &#125;&#125; 参考博客： https://www.cnblogs.com/musecho/p/11703227.html","categories":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}]},{"title":"开发出现的问题","slug":"开发出现的问题","date":"2020-08-24T03:16:53.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/08/24/开发出现的问题/","link":"","permalink":"https://summercat7.github.io/2020/08/24/开发出现的问题/","excerpt":"","text":"开发中遇到的小问题汇总线程Thread中声明式事务不起作用 使用编程式事务 123456789101112131415@Override public void run() &#123; DefaultTransactionDefinition def = new DefaultTransactionDefinition(); def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); PlatformTransactionManager txManager = ContextLoader.getCurrentWebApplicationContext().getBean(PlatformTransactionManager.class); TransactionStatus status = txManager.getTransaction(def); try &#123; testDao.save(entity); txManager.commit(status); // 提交事务 &#125; catch (Exception e) &#123; System.out.println(\"异常信息：\" + e.toString()); txManager.rollback(status); // 回滚事务 &#125; &#125; oracle to_number转换无效数字的解决方案 SELECT to_number(nvl2(translate(‘20/‘,’1234567890.’,’&#39;),’0’,’20/‘)) from dual; 生成随机数：select dbms_random.value(30,70) from dual; 保留三位小数：trunc(3.141592,3) Oracle 强制中止正在执行的SQL语句– 1 查询正在执行的sql语句 1234567select b.sid, b.username, b.serial#, a.spid, b.paddr, c.sql_text, b.machinefrom v$process a, v$session b, v$sqlarea cwhere a.addr = b.paddrand b.sql_hash_value = c.hash_value; – 2 根据sid与serial# kill 需要中止的sql语句 1234select sql_text, b.sid,b.serial#, 'alter system kill session'''||b.SID||','||b.serial#||''';',b.usernamefrom v$process a, v$session b, v$sqlarea cwhere a.addr = b.paddrand b.sql_hash_value = c.hash_value – 3 查询oracle当前被锁对象 12345select a.session_id, c.serial#, a.locked_mode, a.oracle_username, a.os_user_name, c.machine, c.terminal, b.object_name, c.logon_timefrom v$locked_object a, all_objects b, v$session cwhere a.object_id = b.object_id and a.session_id = c.sidorder by c.sid, c.serial#; 使用rclone对minIO数据迁移1 注意事项 两台机器的时区及时间要保持一致 2.1 rclone安装1curl https://rclone.org/install.sh | sudo bash 2.2 生成配置文件1rclone config 按照提示一步步，输入相应配置，即可。生成的文件位于：${HOME}/.config/rclone/目录下。 rclone.conf 配置文件信息： 1234567891011121314151617181920[minio]type = s3provider = Minioenv_auth = falseaccess_key_id = miniosecret_access_key = minio123region = cn-east-1endpoint = http://minio.old.k8s.comlocation_constraint =server_side_encryption =[minio1]type = s3provider = Minioenv_auth = falseaccess_key_id = miniosecret_access_key = minio123region = cn-east-1endpoint = http://minio.new.k8s.comlocation_constraint =server_side_encryption = 3 开始迁移1rclone sync minio:agile-service minio1:agile-service sync : 数据同步 copy : 数据拷贝 idea开启状态时redis启动闪退https://blog.csdn.net/qq_40686003/article/details/100995177 Linux增量更新jar包内容https://bbs.huaweicloud.com/blogs/155582 json 转 泛型123456789101112131415161718192021222324252627282930313233343536 List&lt;BaseDto&lt;PersonBodyDto&gt;&gt; restList = convertList(JSONObject.parseObject(JSONObject.toJSONString(restMap)), new TypeReference&lt;List&lt;BaseDto&lt;PersonBodyDto&gt;&gt;&gt;()&#123;&#125;);public &lt;T extends BaseDtoPoint&gt; List&lt;BaseDto&lt;T&gt;&gt; convertList(JSONObject restObject, TypeReference&lt;List&lt;BaseDto&lt;T&gt;&gt;&gt; typeReference) &#123; List&lt;BaseDto&lt;T&gt;&gt; restList = new ArrayList&lt;&gt;(); if (restObject != null) &#123; if (\"SUCCESS\".equals(restObject.getString(\"msg\"))) &#123; JSONArray restData = restObject.getJSONArray(\"data\"); if (restData != null) &#123; JSONObject resultData = restData.getJSONObject(0); if (null != resultData) &#123; JSONArray resultArr = JSONArray.parseArray(JSON.toJSONString(resultData.get(\"data\"))); if (resultArr != null) &#123; restList = JSON.parseObject(resultArr.toJSONString(), typeReference.getType()); &#125; &#125; &#125; &#125; &#125; for (BaseDto&lt;T&gt; tBaseDto : restList) &#123; BaseDtoPoint baseDtoPoint = (BaseDtoPoint)tBaseDto.getSource(); String pointNo = baseDtoPoint.getCameraId(); if (StringUtil.isNotBlank(pointNo)) &#123; Object o = RestfulPointCache.getInstance().get(\"PointNo\" + pointNo); if (o != null &amp;&amp; o instanceof PbdBasePoint) &#123; PbdBasePoint basePoint = (PbdBasePoint) o; basePoint.setPotNeartList(null); tBaseDto.setPbdBasePoint(basePoint); &#125; &#125; &#125; return restList;&#125; 延迟队列（订单过期自动删除）https://juejin.cn/post/6844904150703013901","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-07-08T03:48:15.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/07/08/单例模式/","link":"","permalink":"https://summercat7.github.io/2020/07/08/单例模式/","excerpt":"","text":"单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 单例模式的几种实现方式 使用推荐： 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 12345678910111213141516171819/** * 1、懒汉式，线程不安全 * 是否 Lazy 初始化：是 * 是否多线程安全：否 * 实现难度：易 * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */public class Singleton01 &#123; private static Singleton01 instance; private Singleton01 ()&#123;&#125; public static Singleton01 getInstance() &#123; if (instance == null) &#123; instance = new Singleton01(); &#125; return instance; &#125;&#125; 1234567891011121314151617181920/** * 2、懒汉式，线程安全 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：易 * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */public class Singleton02 &#123; private static Singleton02 instance; private Singleton02 ()&#123;&#125; public static synchronized Singleton02 getInstance() &#123; if (instance == null) &#123; instance = new Singleton02(); &#125; return instance; &#125;&#125; 1234567891011121314151617181920/** * 3、饿汉式 * 是否 Lazy 初始化：否 * 是否多线程安全：是 * 实现难度：易 * 描述：这种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化， * 虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 */public class Singleton03 &#123; private static Singleton03 instance = new Singleton03(); private Singleton03 ()&#123;&#125; public static Singleton03 getInstance() &#123; return instance; &#125;&#125; 123456789101112131415161718192021222324/** * 4、双检锁/双重校验锁（DCL，即 double-checked locking） * JDK 版本：JDK1.5 起 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：较复杂 * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * getInstance() 的性能对应用程序很关键。 */public class Singleton04 &#123; private volatile static Singleton04 singleton; private Singleton04 ()&#123;&#125; public static Singleton04 getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton04.class) &#123; if (singleton == null) &#123; singleton = new Singleton04(); &#125; &#125; &#125; return singleton; &#125;&#125; 1234567891011121314151617181920212223242526/** * 5、登记式/静态内部类 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：一般 * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。 * 对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。 * 这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 * * 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是： * 第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果）， * 而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用， * 只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。 * 想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化， * 因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。 * 这个时候，这种方式相比第 3 种方式就显得很合理。 */public class Singleton05 &#123; private static class SingletonHolder &#123; private static final Singleton05 INSTANCE = new Singleton05(); &#125; private Singleton05 ()&#123;&#125; public static final Singleton05 getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 123456789101112131415161718/** * 6、枚举 * JDK 版本：JDK1.5 起 * 是否 Lazy 初始化：否 * 是否多线程安全：是 * 实现难度：易 * 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 * * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制， * 防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 * 不能通过 reflection attack(反射) 来调用私有构造方法。 */public enum Singleton06 &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://summercat7.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://summercat7.github.io/tags/设计模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://summercat7.github.io/categories/设计模式/"}]},{"title":"ElasticSearch的使用","slug":"ElasticSearch的使用","date":"2020-06-06T09:26:09.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/06/ElasticSearch的使用/","link":"","permalink":"https://summercat7.github.io/2020/06/06/ElasticSearch的使用/","excerpt":"","text":"ElasticSearch的使用1、下载与配置 解压后在bin里运行elasticSearch脚本启动 默认9200端口为http协议，9300端口为Tcp协议 2、图形化界面elasticsearch-head 的安装与使用 elasticsearch-head是试用nodejs开发的，在使用之前先安装nodejs 安装grunt 12npm install -g grunt-clinpm install 启动服务 1grunt server 修改elasticSearch/conf/elasticsearch.yml允许跨域 12http.cors.enabled: truehttp.cors.allow-origin: \"*\" 3、使用Http请求操作3.1 创建index1PUT http://127.0.0.1:9200/&#123;&#123;index&#125;&#125; 123456789101112131415161718192021222324&#123; \"mappings\":&#123; \"type\":&#123; \"properties\":&#123; \"id\":&#123; \"store\":true, \"type\":\"long\" &#125;, \"title\":&#123; \"analyzer\":\"standard\", \"store\":true, \"type\":\"text\", \"index\":true &#125;, \"content\":&#123; \"analyzer\":\"standard\", \"store\":true, \"type\":\"text\", \"index\":true &#125; &#125; &#125; &#125;&#125; 给已创建的index设置mapping信息 1POST http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/_mapping 1234567891011121314151617181920&#123; &quot;properties&quot;:&#123; &quot;id&quot;:&#123; &quot;store&quot;:true, &quot;type&quot;:&quot;long&quot; &#125;, &quot;title&quot;:&#123; &quot;analyzer&quot;:&quot;standard&quot;, &quot;store&quot;:true, &quot;type&quot;:&quot;text&quot;, &quot;index&quot;:true &#125;, &quot;content&quot;:&#123; &quot;analyzer&quot;:&quot;standard&quot;, &quot;store&quot;:true, &quot;type&quot;:&quot;text&quot;, &quot;index&quot;:true &#125; &#125;&#125; 3.2 删除index1DELETE http://127.0.0.1:9200/&#123;&#123;index&#125;&#125; 3.3 创建Document1POST http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/&#123;&#123;id&#125;&#125; 12345&#123; \"id\":1, \"title\":\"新添加的标题\", \"content\":\"新添加的内容\"&#125; 3.4 删除Document1DELETE http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/&#123;&#123;id&#125;&#125; 3.5 修改Document 与添加的操作一样，底层在检测到有相同id存在时会先删除后添加 3.6 根据id查询1GET http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/&#123;&#123;id&#125;&#125; 3.7 根据关键字查询1POST http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/_search 1234567&#123; \"query\":&#123; \"term\":&#123; \"title\":\"新\" &#125; &#125;&#125; 3.7 根据字符串查询（分词后查询）1POST http://127.0.0.1:9200/&#123;&#123;index&#125;&#125;/&#123;&#123;type&#125;&#125;/_search 12345678&#123; \"query\":&#123; \"query_string\":&#123; \"default_field\":\"title\", \"query\":\"的标题\" &#125; &#125;&#125; 3.8 查看分词结果1POST http://127.0.0.1:9200/_analyze 1234&#123; \"text\":\"测试分词器，后边是测试内容：spring cloud实战\", \"analyzer\":\"ik_max_word\"&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"Lucene的原理及使用","slug":"Lucene的原理及使用","date":"2020-06-06T08:32:48.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/06/Lucene的原理及使用/","link":"","permalink":"https://summercat7.github.io/2020/06/06/Lucene的原理及使用/","excerpt":"","text":"Lucene的原理及使用1、什么是全文检索计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。 2、Lucene的介绍 Lucene是一套用于全文检索和搜寻的开源程序库。 Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻。 Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品。 3、Lucene的存储结构Lucene的索引结构是有层次结构的，主要分以下几个层次： 索引(Index)： 一个目录一个索引，在Lucene中一个索引是放在一个文件夹中的。 如左图，同一文件夹中的所有的文件构成一个Lucene索引。 段(Segment)： 一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。在建立索引的时候对性能影响最大的地方就是在将索引写入文件的时候, 所以在具体应用的时候就需要对此加以控制，段(Segment) 就是实现这种控制的。稍后详细描述段(Segment) 的控制策略。 如上图，具有相同前缀文件的属同一个段，图中共两个段 “_0” 和 “_1”。 segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。 文档(Document)： 文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。 新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。 域(Field)： 一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。 不同域的索引方式可以不同。 词(Term)： 词是索引的最小单位，是经过词法分析和语言处理后的字符串。 4、Lucene的使用4.1、索引库的创建和分词的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import org.apache.commons.io.FileUtils;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.TokenStream;import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;import org.apache.lucene.document.*;import org.apache.lucene.index.*;import org.apache.lucene.search.*;import org.apache.lucene.store.Directory;import org.apache.lucene.store.FSDirectory;import org.apache.lucene.store.RAMDirectory;import org.junit.Test;import org.wltea.analyzer.lucene.IKAnalyzer;import java.io.File;public class LuceneFirst &#123; @Test public void createIndex() throws Exception &#123;//1、创建一个Director对象，指定索引库保存的位置。 //把索引库保存在内存中 //Directory directory = new RAMDirectory(); //把索引库保存在磁盘 Directory directory = FSDirectory.open(new File(\"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\index\").toPath()); //2、基于Directory对象创建一个IndexWriter对象 IndexWriterConfig config = new IndexWriterConfig(new IKAnalyzer()); IndexWriter indexWriter = new IndexWriter(directory, config); //3、读取磁盘上的文件，对应每个文件创建一个文档对象。 File dir = new File(\"E:\\\\桌面文件\\\\other\\\\61.会员版(2.0)-就业课(2.0)-Lucene\\\\lucene\\\\02.参考资料\\\\searchsource\"); File[] files = dir.listFiles(); for (File f : files) &#123; //取文件名 String fileName = f.getName(); //文件的路径 String filePath = f.getPath(); //文件的内容 String fileContent = FileUtils.readFileToString(f, \"utf-8\"); //文件的大小 long fileSize = FileUtils.sizeOf(f); //创建Field //参数1：域的名称，参数2：域的内容，参数3：是否存储 Field fieldName = new TextField(\"name\", fileName, Field.Store.YES); //Field fieldPath = new TextField(\"path\", filePath, Field.Store.YES); Field fieldPath = new StoredField(\"path\", filePath); Field fieldContent = new TextField(\"content\", fileContent, Field.Store.YES); //Field fieldSize = new TextField(\"size\", fileSize + \"\", Field.Store.YES); Field fieldSizeValue = new LongPoint(\"size\", fileSize); Field fieldSizeStore = new StoredField(\"size\", fileSize); //创建文档对象 Document document = new Document(); //向文档对象中添加域 document.add(fieldName); document.add(fieldPath); document.add(fieldContent); //document.add(fieldSize); document.add(fieldSizeValue); document.add(fieldSizeStore); //5、把文档对象写入索引库 indexWriter.addDocument(document); &#125; //6、关闭indexwriter对象 indexWriter.close(); &#125; @Test public void searchIndex() throws Exception &#123; //1、创建一个Director对象，指定索引库的位置 Directory directory = FSDirectory.open(new File(\"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\index\").toPath()); //2、创建一个IndexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //3、创建一个IndexSearcher对象，构造方法中的参数indexReader对象。 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //4、创建一个Query对象，TermQuery Query query = new TermQuery(new Term(\"name\", \"spring\")); //5、执行查询，得到一个TopDocs对象 //参数1：查询对象 参数2：查询结果返回的最大记录数 TopDocs topDocs = indexSearcher.search(query, 10); //6、取查询结果的总记录数 System.out.println(\"查询总记录数：\" + topDocs.totalHits); //7、取文档列表 ScoreDoc[] scoreDocs = topDocs.scoreDocs; //8、打印文档中的内容 for (ScoreDoc doc : scoreDocs) &#123; //取文档id int docId = doc.doc; //根据id取文档对象 Document document = indexSearcher.doc(docId); System.out.println(document.get(\"name\")); System.out.println(document.get(\"path\")); System.out.println(document.get(\"size\")); //System.out.println(document.get(\"content\")); System.out.println(\"-----------------\"); &#125; //9、关闭IndexReader对象 indexReader.close(); &#125; @Test public void testTokenStream() throws Exception &#123; //1）创建一个Analyzer对象，StandardAnalyzer对象// Analyzer analyzer = new StandardAnalyzer(); Analyzer analyzer = new IKAnalyzer(); //2）使用分析器对象的tokenStream方法获得一个TokenStream对象 TokenStream tokenStream = analyzer.tokenStream(\"\", \"查看分析器的效果\"); //3）向TokenStream对象中设置一个引用，相当于数一个指针 CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); //4）调用TokenStream对象的rest方法。如果不调用抛异常 tokenStream.reset(); //5）使用while循环遍历TokenStream对象 while(tokenStream.incrementToken()) &#123; System.out.println(charTermAttribute.toString()); &#125; //6）关闭TokenStream对象 tokenStream.close(); &#125;&#125; 4.2、 索引库的维护（增删改）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.document.StoredField;import org.apache.lucene.document.TextField;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.index.IndexWriterConfig;import org.apache.lucene.index.Term;import org.apache.lucene.store.FSDirectory;import org.junit.Before;import org.junit.Test;import org.wltea.analyzer.lucene.IKAnalyzer;import java.io.File;public class IndexManager &#123; private IndexWriter indexWriter; @Before public void init() throws Exception &#123; //创建一个IndexWriter对象，需要使用IKAnalyzer作为分析器 indexWriter = new IndexWriter(FSDirectory.open(new File(\"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\index\").toPath()), new IndexWriterConfig(new IKAnalyzer())); &#125; @Test public void addDocument() throws Exception &#123; //创建一个IndexWriter对象，需要使用IKAnalyzer作为分析器 IndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(\"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\index\").toPath()), new IndexWriterConfig(new IKAnalyzer())); //创建一个Document对象 Document document = new Document(); //向document对象中添加域 document.add(new TextField(\"name\", \"新添加的文件\", Field.Store.YES)); document.add(new TextField(\"content\", \"新添加的文件内容\", Field.Store.NO)); document.add(new StoredField(\"path\", \"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\helo\")); // 把文档写入索引库 indexWriter.addDocument(document); //关闭索引库 indexWriter.close(); &#125; @Test public void deleteAllDocument() throws Exception &#123; //删除全部文档 indexWriter.deleteAll(); //关闭索引库 indexWriter.close(); &#125; @Test public void deleteDocumentByQuery() throws Exception &#123; indexWriter.deleteDocuments(new Term(\"name\", \"apache\")); indexWriter.close(); &#125; @Test public void updateDocument() throws Exception &#123; //创建一个新的文档对象 Document document = new Document(); //向文档对象中添加域 document.add(new TextField(\"name\", \"更新之后的文档\", Field.Store.YES)); document.add(new TextField(\"name1\", \"更新之后的文档2\", Field.Store.YES)); document.add(new TextField(\"name2\", \"更新之后的文档3\", Field.Store.YES)); //更新操作 indexWriter.updateDocument(new Term(\"name\", \"spring\"), document); //关闭索引库 indexWriter.close(); &#125;&#125; 4.3、 索引库的查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import org.apache.lucene.document.Document;import org.apache.lucene.document.LongPoint;import org.apache.lucene.index.DirectoryReader;import org.apache.lucene.index.IndexReader;import org.apache.lucene.queryparser.classic.QueryParser;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.FSDirectory;import org.junit.Before;import org.junit.Test;import org.wltea.analyzer.lucene.IKAnalyzer;import java.io.File;public class SearchIndex &#123; private IndexReader indexReader; private IndexSearcher indexSearcher; @Before public void init() throws Exception &#123; indexReader = DirectoryReader.open(FSDirectory.open(new File(\"E:\\\\code\\\\java\\\\test\\\\luceneTemp\\\\index\").toPath())); indexSearcher = new IndexSearcher(indexReader); &#125; @Test public void testRangeQuery() throws Exception &#123; //创建一个Query对象 Query query = LongPoint.newRangeQuery(\"size\", 0L, 100L); printResult(query); &#125; private void printResult(Query query) throws Exception &#123; //执行查询 TopDocs topDocs = indexSearcher.search(query, 10); System.out.println(\"总记录数：\" + topDocs.totalHits); ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc doc:scoreDocs)&#123; //取文档id int docId = doc.doc; //根据id取文档对象 Document document = indexSearcher.doc(docId); System.out.println(document.get(\"name\")); System.out.println(document.get(\"path\")); System.out.println(document.get(\"size\")); //System.out.println(document.get(\"content\")); System.out.println(\"-----------------\"); &#125; indexReader.close(); &#125; @Test public void testQueryParser() throws Exception &#123; //创建一个QueryPaser对象，两个参数 QueryParser queryParser = new QueryParser(\"name\", new IKAnalyzer()); //参数1：默认搜索域，参数2：分析器对象 //使用QueryPaser对象创建一个Query对象 Query query = queryParser.parse(\"lucene是一个Java开发的全文检索工具包\"); //执行查询 printResult(query); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"docker入门","slug":"docker入门","date":"2020-06-04T09:33:35.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/04/docker入门/","link":"","permalink":"https://summercat7.github.io/2020/06/04/docker入门/","excerpt":"","text":"Docker使用入门1. Docker安装12345678910111213141516171819202122232425262728293031323334sudo yum update#安装需要的软件包，yum-util提供yum-config-manager，另外两个是devicemapper驱动依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置yum源为阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#安装dockersudo yum install docker-ce#查看docker版本docker -v#设置ustc的镜像vi /etc/docker/daemon.json&#123;\"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]&#125;#启动dockersystemctl start docker#启动状态systemctl status docker#停止dockersystemctl stop docker#重启dockersystemctl start docker#开机自启动systemctl enable docker#docker概要docker info#在线帮助文档docker --help 2.Docker镜像命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#查看镜像docker images#搜索镜像docker search xxx#拉取镜像docker pull xxx:x.x#删除镜像docker rmi 镜像ID#删除所有镜像docker rmi `docker images -q`#查看运行的容器docker ps#查看所有容器docker ps -a#查看最后一次运行的容器docker ps -l#查看停止的容器docker ps -f status=exited#交互方式启动容器（exit后关闭）docker run -it --name=mycentos centos:7 /bin/bash#守护方式启动容器（后台运行）docker run -id --name=mycentos2 centos:7#进入守护式容器docker exec -it mycentos2 /bin/bash#容器停止docker stop 容器ID/容器NAME#启动停止的容器docker start 容器ID/容器NAME#文件拷贝docker cp 文件名 mycentos2:/usr/localdocker cp mycentos2:/usr/local/文件名 拷出后文件名#目录挂载docker run -id --name=mycentos3 -v /usr/local/myhtml(宿主机目录):/usr/local/myhtml(容器目录) centos:7#查看容器信息docker inspect mycentos3#查看容器ipdocker inspect --format='&#123; &#123;.NetworkSettings.IPAddress&#125; &#125;' mycentos3#删除容器(先停止容器)docker rm mycentos3 3. Docker应用部署3.1 MySQL部署12345678910111.拉取mysql镜像docker pull centos/mysql-57-centos72.创建容器-p 33306(宿主机端口):3306(容器端口)docker run -id --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos73.进入MySQL容器docker exec -it tensquare_mysql /bin/bash4.登陆MySQLmysql -u root -p5.远程登录mysql连接宿主机的IP，指定端口为33306 3.2 tomcat部署1234567891.拉取镜像docker pull tomcat:7-jre72.创建容器docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7上传文件（sftp连接）put d:\\..\\cas.war转移到指定目录mv cas.war /usr/local/webapps 3.3 Nginx部署123456789101112131.拉取镜像docker pull nginx2.创建Nginx容器docker run -di --name=mynginx -p 80:80 nginxdocker exec -it mynginx /bin/bashcd etccd nginxcat nginx.confcd conf.dcat default.confexitdocker cp html mynginx:/usr/share/nginx/ 3.4 Redis部署12345671.拉取镜像docker pull redis2.创建容器docker run -di --name=myredis -p 6379:6379 redis远程连接测试redis-cli -h 192.168.159.100 4. docker迁移与备份123456789101112131415161718192021222324#容器保存为镜像docker commit mynginx mynginx_i#镜像备份(将镜像保存为tar文件)docker save -o mynginx.tar mynginx_i#镜像恢复与迁移docker load -i mynginx.tarDockerfile#私有仓库docker run -di --name=registry -p 5000:5000 registry#修改daemon.jsonvi /etc/docker/daemon.json#添加&#123;\"insecure-registries\":[\"192.168.184.141:5000\"]&#125;#重启docker服务systemctl restart docker#镜像上传至私有仓库1.标志镜像docker tag jdk1.8 192.168.184.141:5000/jdk1.82.上传标志的镜像docker push 192.168.184.141:5000/jdk1.8","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"canal整合rocketmq","slug":"canal整合rocketmq","date":"2020-06-04T06:52:08.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/04/canal整合rocketmq/","link":"","permalink":"https://summercat7.github.io/2020/06/04/canal整合rocketmq/","excerpt":"","text":"canal整合rocketmq1. 数据库设置 修改需要被同步的数据库 /etc/my.cfg配置，有则修改无则添加 12345[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复binlog-rows-query-log-events = 1 #查看完整的sql语句 canal的原理是模拟自己为mysql slave，创建有mysql slave的相关权限的用户 1234567CREATE USER canal IDENTIFIED BY 'canal'; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON . TO 'canal'@'%';GRANT ALL PRIVILEGES ON . TO 'canal'@'%' ;FLUSH PRIVILEGES; 2. Canal配置修改instance 配置文件 vi conf/example/instance.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 数据库实例地址，主数据库canal.instance.master.address=192.168.1.48:3306canal.instance.master.journal.name=canal.instance.master.position=canal.instance.master.timestamp=canal.instance.master.gtid=# rds oss binlogcanal.instance.rds.accesskey=canal.instance.rds.secretkey=canal.instance.rds.instanceId=# table meta tsdb infocanal.instance.tsdb.enable=true#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb#canal.instance.tsdb.dbUsername=canal#canal.instance.tsdb.dbPassword=canal#canal.instance.standby.address =#canal.instance.standby.journal.name =#canal.instance.standby.position =#canal.instance.standby.timestamp =#canal.instance.standby.gtid=# username/password 数据库帐号密码canal.instance.dbUsername=tradesrvcanal.instance.dbPassword=Qt!S!U3wkmuu97_Icanal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false# table regex 白名单过滤canal.instance.filter.regex=trade\\\\..*# table black regex 黑名单过滤canal.instance.filter.black.regex=mysql\\\\..*# mq config#定义主题canal.mq.topic=example# dynamic topic route by schema or table regex# 根据正则表达式做动态topic#canal.mq.dynamicTopic=example:.*\\\\..*#消息分区canal.mq.partition=0# hash partition config#canal.mq.partitionsNum=3#canal.mq.partitionHash=test.table:id^name,.*\\\\..*################################################# 修改canal 配置文件vi conf/canal.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778########################################################## common argument ############# ##################################################canal.manager.jdbc.url=jdbc:mysql://127.0.0.1:3306/canal_manager?useUnicode=true&amp;characterEncoding=UTF-8#canal.manager.jdbc.username=root#canal.manager.jdbc.password=121212#canal server的唯一标识，没有实际意义，但是我们建议同一个cluster上的不同节点，其ID尽可能唯一canal.id =150 #canal server因为binding的本地IP地址，建议使用内网（唯一，集群可见，consumer可见）IP地址，比如“10.0.1.21”。 #此IP主要为canalServer提供TCP服务而使用，将会被注册到ZK中,Consumer将与此IP建立连接。canal.ip =192.168.1.150#cannal server的TCP端口canal.port = 11111canal.metrics.pull.port = 11112#zookeeper地址，可集群canal.zkServers =192.168.1.150:2181# flush data to zkcanal.zookeeper.flush.period = 1000canal.withoutNetty = false# tcp, kafka, RocketMQcanal.serverMode = RocketMQ# flush meta cursor/parse position to file#canal将parse、position数据写入的本地文件目录 canal.file.data.dir = $&#123;canal.conf.dir&#125;canal.file.flush.period = 1000## memory store RingBuffer size, should be Math.pow(2,n)canal.instance.memory.buffer.size = 16384## memory store RingBuffer used memory unit size , default 1kbcanal.instance.memory.buffer.memunit = 1024 ## meory store gets mode used MEMSIZE or ITEMSIZEcanal.instance.memory.batch.mode = MEMSIZEcanal.instance.memory.rawEntry = true########################################################## destinations ############# ##################################################添加实例，用逗号隔开canal.destinations = example,example1# conf root dircanal.conf.dir = ../conf# auto scan instance dir add/remove and start/stop instancecanal.auto.scan = truecanal.auto.scan.interval = 5canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml#canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xmlcanal.instance.global.mode = springcanal.instance.global.lazy = false#canal.instance.global.manager.address = 127.0.0.1:1099#canal.instance.global.spring.xml = classpath:spring/memory-instance.xmlcanal.instance.global.spring.xml = classpath:spring/file-instance.xml#canal.instance.global.spring.xml = classpath:spring/default-instance.xml########################################################### MQ ################################################################ kafka/rocketmq 集群配置: 192.168.1.117:9092,192.168.1.118:9092,192.168.1.119:9092canal.mq.servers = 192.168.1.150:9876canal.mq.retries = 0canal.mq.batchSize = 16384canal.mq.maxRequestSize = 1048576canal.mq.lingerMs = 1canal.mq.bufferMemory = 33554432#消息生产组名canal.mq.producerGroup = Canal-Producer# Canal的batch size, 默认50K, 由于kafka最大消息体限制请勿超过1M(900K以下)canal.mq.canalBatchSize = 30# Canal get数据的超时时间, 单位: 毫秒, 空为不限超时canal.mq.canalGetTimeout = 100# 是否为flat json格式对象canal.mq.flatMessage = truecanal.mq.compressionType = nonecanal.mq.acks = all# use transaction for kafka flatMessage batch producecanal.mq.transaction = false#canal.mq.properties. = 3. RocketMQ配置 修改配置文件 12cd distribution/target/apache-rocketmq/confvim broker.conf 在broker.conf配置文件添加以下内容 123456789101112brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0brokerIP1=192.168.159.100 #这个IP是本地内网IP地址deleteWhen = 04fileReservedTime = 48brokerRole = ASYNC_MASTERflushDiskType = ASYNC_FLUSHautoCreateTopicEnable=true #自动创建topic配置autoCreateSubscriptionGroup=true #自动创建注册组配置rejectTransactionMessage=false #默认falsetransactionTimeOut=6000 #超时时间 启动RocketMQ消费者 修改application配置文件后启动服务 123456789101112131415161718192021222324252627282930313233343536server.port=8804#用来作为数据仓库的数据库配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://192.168.0.118/trade?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;generateSimpleParameterMetadata=true&amp;useSSL=false&amp;&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=2%YcIZXyFH7LsC_y# NameServer地址apache.rocketmq.namesrvAddr=192.168.1.150:9876# 生产者的主题 死信队列apache.rocketmq.producer.topic=exceptionSQL# 生产者的组名 死信队列apache.rocketmq.producer.producerGroup=canal_producer_client# 消费者的主题apache.rocketmq.consumer.topic=example# 消费者的组名apache.rocketmq.consumer.PushConsumer=canal_consumer_client# 消费线程池最大线程数。默认10 apache.rocketmq.consumer.consumeThreadMin=10# 消费线程池最大线程数。默认20 apache.rocketmq.consumer.consumeThreadMax=20# 批量消费，一次消费多少条消息。默认1 apache.rocketmq.consumer.consumeMessageBatchMaxSize=1# 批量拉消息，一次最多拉多少条。默认32 apache.rocketmq.consumer.pullBatchSize=32#定时批量执行sql的间隔时间apache.rocketmq.consumer.batchExcuteTime=0/3 * * * * ?#过滤sql语句，不执行的语句类型apache.rocketmq.consumer.TypeFilter=drop#过滤表 黑白名单 格式：库名~表名，表名; *代表所有，库之间分号隔开apache.rocketmq.consumer.tableWhite=message~*;trade~*;apache.rocketmq.consumer.tableBlack=","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"Centos7部署RocketMQ","slug":"rocketmq","date":"2020-06-03T07:00:20.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/03/rocketmq/","link":"","permalink":"https://summercat7.github.io/2020/06/03/rocketmq/","excerpt":"","text":"Centos7部署RocketMQ1. 环境准备系统环境：Centos7 x64 JDK：jdk-8u171-linux-x64 Maven：3.2.x以上的版本均可 2. 下载RocketMQ1wget https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.7.0/rocketmq-all-4.7.0-source-release.zip 3. 解压1unzip -d /opt/myapp/ rocketmq-all-4.7.0-source-release.zip 4. 使用MAVEN进行打包 执行mvn打包会下好多的依赖包 ，时间较长 12345cd /opt/myapp/rocketmq-all-4.7.0/mvn -Prelease-all -DskipTests clean install -Ucd distribution/target/apache-rocketmq 5. 修改配置 一般到这里按照官方文档是可以启动的，但是最关键的一点，除了上面环境的要求外，还有个硬性要求，就是内存不能低于4G 12345678910111213141516cd binvim runserver.sh # 找到如下配置JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g\"# 修改成你可以接受的范围JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx521m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"vim runbroker.sh# 找到如下配置JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"# 修改成你可以接受的范围JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m\" 6. 配置环境变量1234567vim /etc/profileexport ROCKETMQ_HOME=/opt/myapp/rocketmq/rocketmq-all-4.7.0-source-release/distribution/target/rocketmq-4.7.0/rocketmq-4.7.0export PATH=$&#123;ROCKETMQ_HOME&#125;/bin:$&#123;PATH&#125;# 使配置生效source /etc/profile 7. 启动Name Server123nohup sh mqnamesrv &amp;tail -f ~/logs/rocketmqlogs/namesrv.log 8. 启动Broker123nohup sh mqbroker -n localhost:9876 &amp;tail -f ~/logs/rocketmqlogs/broker.log 9. 执行测试添加环境变量： 1export NAMESRV_ADDR=localhost:9876 建议分别于不同两个窗口执行以下两个脚本 12# 生产者生产消息sh tools.sh org.apache.rocketmq.example.quickstart.Producer 12# 消费者消费消息sh tools.sh org.apache.rocketmq.example.quickstart.Consumer 10. 关闭服务12sh mqshutdown brokersh mqshutdown namesrv 11. 可视化服务配置11.1 下载123cd /opt/myjava/rocketmqgit clone https://github.com/apache/rocketmq-externals 11.2 修改配置文件12345678cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-console/src/main/resourcesvim application.properties# 修改如下配置server.port=8081 // 服务端口号rocketmq.config.namesrvAddr=127.0.0.1:9876 // 配置服务地址rocketmq.config.dataPath=/tmp/rocketmq-console/data // mq数据路径，可以自己修改 11.3 使用maven打包12cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-consolemvn clean package -Dmaven.test.skip=true 11.4 运行运行后访问对应的端口，如：http://192.168.159.100.8081 123cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-console/targetjava -jar rocketmq-console-ng-1.0.1.jar 指定端口运行和rocketmq地址运行 1java -jar rocketmq-console-ng-1.0.0.jar --server.port=8081 --rocketmq.config.namesrvAddr=127.0.0.1:9876 12. 自定义测试自动创建Topic 1nohup sh mqbroker -n localhost:9876 autoCreateTopicEnable=true &gt; ~/logs/rocketmqlogs/broker.log 2&gt;&amp;1 &amp; RocketMQ常用命令 1234567891011121314#查看所有消费组group:sh mqadmin consumerProgress -n 127.0.0.1:9876#查看所有topic:sh mqadmin topicList -n 127.0.0.1:9876#新增topic:sh mqadmin updateTopic -n localhost:9876 -b localhost:10911 -t mytopic#删除topicsh mqadmin deleteTopic –n 127.0.0.1:9876 –c DefaultCluster –t mytopic#查询集群消息sh mqadmin clusterList -n 127.0.0.1:9876 生产者: 12345678910111213141516171819202122232425import com.alibaba.rocketmq.client.producer.DefaultMQProducer;import com.alibaba.rocketmq.client.producer.SendResult;import com.alibaba.rocketmq.common.message.Message;public class ProducerTest &#123; public static void main(String[] args) throws Exception &#123; DefaultMQProducer producer = new DefaultMQProducer(\"producerGroup1\"); producer.setNamesrvAddr(\"192.168.159.100:9876\"); producer.setInstanceName(\"instance1\"); //为避免程序启动的时候报错，添加此代码，可以让rocketMq自动创建topickey producer.setCreateTopicKey(\"AUTO_CREATE_TOPIC_KEY\"); producer.start(); System.out.println(\"开始发送数据\"); try &#123; for (int i = 0; i &lt; 3; i++) &#123; Message msg = new Message(\"mytopic\", \"mytag\", (\"hello world \" + i).getBytes()); SendResult sendResult = producer.send(msg); System.out.println(\"发送成功 \" + new String(msg.getBody())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; producer.shutdown(); &#125;&#125; 消费者: 123456789101112131415161718192021222324252627282930313233import com.alibaba.rocketmq.client.consumer.DefaultMQPushConsumer;import com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;import com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;import com.alibaba.rocketmq.client.consumer.listener.MessageListenerConcurrently;import com.alibaba.rocketmq.common.consumer.ConsumeFromWhere;import com.alibaba.rocketmq.common.message.Message;import com.alibaba.rocketmq.common.message.MessageExt;import java.util.List;public class ConsumerTest &#123; public static void main(String[] args) &#123; DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"producerGroup1\"); consumer.setNamesrvAddr(\"192.168.159.100:9876\"); System.out.println(\"开始接收数据\"); try &#123; // 设置topic和标签 consumer.subscribe(\"mytopic\", \"mytag\"); // 程序第一次启动从消息队列头取数据 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener(new MessageListenerConcurrently() &#123; public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext Context) &#123; Message msg = list.get(0); System.out.println(\"收到数据：\" + new String(msg.getBody())); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125;); consumer.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"canal的使用","slug":"canal","date":"2020-06-02T04:04:32.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/02/canal/","link":"","permalink":"https://summercat7.github.io/2020/06/02/canal/","excerpt":"","text":"CentOS7安装Canal内容参考链接：https://blog.csdn.net/qrjqrjqrj/article/details/102979410 canal的工作原理canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )canal 解析 binary log 对象(原始为 byte 流) 安装1 下载Canal( canal.deployer-1.1.4.tar.gz ) 2 解压到安装目录 1tar -zxvf canal.deployer-1.1.4.tar.gz -C /opt/myapp/canal 3 配置 3.1 mysql开启binlog 1vim /etc/my.cnf ** 在[mysqld]中添加下列语句 12345log-bin=mysql-binbinlog-format=ROWserver_id=1 ** 保存退出后重启mysql，执行systemctl restart mysql 123show variables like 'log_%';show variables like 'binlog_format'; 3.2 创建有slave权限的账号 1234--通过以下语句创建用户canal：create user canal@'%' identified by 'canal';--通过以下语句给用户授权：grant select, replication slave, replication client on *.* to canal@'%'; 3.3 修改Canal Server配置 1vim conf/example/instance.properties 123456canal.instance.mysql.slaveId=1234canal.instance.master.address=127.0.0.1:3306canal.instance.dbUsername=rootcanal.instance.dbPassword=123456 4 代码测试(mysql-&gt;redis) 4.1 pow.xml 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 CanalClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import com.alibaba.fastjson.JSONObject;import com.alibaba.otter.canal.client.CanalConnector;import com.alibaba.otter.canal.client.CanalConnectors;import com.alibaba.otter.canal.protocol.CanalEntry.*;import com.alibaba.otter.canal.protocol.Message;import java.net.InetSocketAddress;import java.util.List;public class CanalClient &#123; public static void main(String args[]) &#123; CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(\"192.168.159.100\", 11111), \"example\", \"\", \"\"); int batchSize = 100; int emptyCount = 0; try &#123; connector.connect(); connector.subscribe(\".*\\\\..*\"); connector.rollback(); int i=0; while (true) &#123; // 获取指定数量的数据 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size();// System.out.println(\"batchId = \" + batchId);// System.out.println(\"size = \" + size); if (batchId == -1 || size == 0) &#123; emptyCount++;// System.out.println(\"empty count : \" + emptyCount); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; emptyCount = 0; printEntry(message.getEntries()); &#125; // 提交确认 connector.ack(batchId); // connector.rollback(batchId); // 处理失败, 回滚数据 &#125; &#125; finally &#123; connector.disconnect(); &#125; &#125; private static void printEntry(List&lt;Entry&gt; entrys) &#123; for (Entry entry : entrys) &#123; if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123; continue; &#125; RowChange rowChage = null; try &#123; rowChage = RowChange.parseFrom(entry.getStoreValue()); &#125; catch (Exception e) &#123; throw new RuntimeException(\"ERROR ## parser of eromanga-event has an error , data:\" + entry.toString(), e); &#125; EventType eventType = rowChage.getEventType(); System.out.println(String.format(\"================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s\", entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(), entry.getHeader().getSchemaName(), entry.getHeader().getTableName(), eventType)); for (RowData rowData : rowChage.getRowDatasList()) &#123; if (eventType == EventType.DELETE) &#123; redisDelete(rowData.getBeforeColumnsList()); &#125; else if (eventType == EventType.INSERT) &#123; redisInsert(rowData.getAfterColumnsList()); &#125; else &#123; System.out.println(\"-------&gt; before\"); printColumn(rowData.getBeforeColumnsList()); System.out.println(\"-------&gt; after\"); printColumn(rowData.getAfterColumnsList()); redisUpdate(rowData.getAfterColumnsList()); &#125; &#125; &#125; &#125; private static void printColumn(List&lt;Column&gt; columns) &#123; for (Column column : columns) &#123; System.out.println(column.getName() + \" : \" + column.getValue() + \" update=\" + column.getUpdated()); &#125; &#125; private static void redisInsert(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.stringSet(\"user:\" + columns.get(0).getValue(), json.toJSONString()); &#125; &#125; private static void redisUpdate(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.stringSet(\"user:\" + columns.get(0).getValue(), json.toJSONString()); &#125; &#125; private static void redisDelete(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.delKey(\"user:\" + columns.get(0).getValue()); &#125; &#125;&#125; 3RedisUtil 1234567891011121314151617181920212223242526272829303132333435import redis.clients.jedis.Jedis;public class RedisUtil &#123; private static Jedis jedis = null; public static synchronized Jedis getJedis() &#123; if (jedis == null) &#123; jedis = new Jedis(\"127.0.0.1\", 6379);// jedis.auth(\"password\"); &#125; return jedis; &#125; public static boolean existKey(String key) &#123; return getJedis().exists(key); &#125; public static void delKey(String key) &#123; getJedis().del(key); &#125; public static String stringGet(String key) &#123; return getJedis().get(key); &#125; public static String stringSet(String key, String value) &#123; return getJedis().set(key, value); &#125; public static void hashSet(String key, String field, String value) &#123; getJedis().hset(key, field, value); &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"CentOS防火墙设置","slug":"centos防火墙","date":"2020-06-02T04:00:32.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/06/02/centos防火墙/","link":"","permalink":"https://summercat7.github.io/2020/06/02/centos防火墙/","excerpt":"","text":"CentOS 6、CentOS7 防火墙端口设置虚拟机上CentOS使用nat联网1vim /etc/sysconfig/network-scripts/ifcfg-eth0 或者是 ifcfg-ens33(centos7) 打开此文件 修改配置文件 123456789TYPE=Ethernet BOOTPROTO=static #静态链接DEVICE=ens33ONBOOT=yesNM_CONTROLLED=yesIPADDR=192.168.211.100 #自己要用的地址（设置在虚拟网卡网关一个ip段）NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.211.2 #网关DNS1=114.114.114.114 #DNS 重启network (root用户) 1service network restart CentOS 6.51.开放指定端口/sbin/iptables -I INPUT -p tcp –dport 端口号 -j ACCEPT //写入修改/etc/init.d/iptables save //保存修改service iptables restart //重启防火墙，修改生效2.关闭指定端口/sbin/iptables -I INPUT -p tcp –dport 端口号 -j DROP //写入修改/etc/init.d/iptables save //保存修改service iptables restart //重启防火墙，修改生效3.查看端口状态/etc/init.d/iptables status CentOS 71.防火墙操作启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalld2.开放指定端口firewall-cmd –zone=public –add-port=80/tcp –permanent //开放端口firewall-cmd –reload //重新载入，使其生效3.关闭指定端口firewall-cmd –zone=public –remove-port=80/tcp –permanent //关闭端口firewall-cmd –reload //重新载入，使其生效4.查看端口状态firewall-cmd –zone=public –query-port=80/tcp //查看端口状态","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2020-04-21T07:39:38.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2020/04/21/Linux基础/","link":"","permalink":"https://summercat7.github.io/2020/04/21/Linux基础/","excerpt":"","text":"一、基础命令：1.1 目录查看 ls [-al]命令：ls [-al] ls 查看当前目录下的所有目录和文件ls -a 查看当前目录下的所有目录和文件（包括隐藏的文件）ls -l 或 ll 列表查看当前目录下的所有目录和文件（列表查看，显示更多信息） （常用）ll -h 功能同上，可查看转换单位后的文件大小ls /dir 查看指定目录下的所有目录和文件 如：ls /usr 命令 : pwd 查看当前所在路径 1.2 目录切换 cd命令：cd 目录 (常用) cd 目录名 切换到当前文件夹下的指定文件夹cd / 切换到根目录cd /usr 切换到根目录下的usr目录cd ../ 切换到上一级目录 或者 cd ..cd ~ 切换到home目录cd - 切换到上次访问的目录 1.3 创建目录【增】 mkdir命令：mkdir 目录 mkdir aaa 在当前目录下创建一个名为aaa的目录mkdir /usr/aaa 在指定目录下创建一个名为aaa的目录mkdir -p aa/bb/cc 在当前目录创建一个多级目录 1.4 删除目录或文件【删】rm命令：rm [-rf] 目录 删除文件：rm 文件 删除当前目录下的文件rm -f 文件 删除当前目录的的文件（不询问） 删除目录：rm -r aaa 递归删除当前目录下的aaa目录rm -rf aaa 递归删除当前目录下的aaa目录（不询问） 全部删除：rm -rf * 将当前目录下的所有目录和文件全部删除rm -rf /* 【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除 1.5 目录修改【改】mv 和 cp一、重命名目录 命令：mv 当前目录 新目录 例如：mv aaa bbb 将目录aaa改为bbb 二、剪切目录 命令：mv 目录名称 目录的新位置 示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面 mv /usr/tmp/aaa /usr 三、拷贝目录 命令：cp -r 目录名称 目录拷贝的目标位置 -r代表递归 示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面 cp /usr/tmp/aaa /usr 二、文件操作2.1 新建文件 touch命令：touch 文件名示例：在当前目录创建一个名为aa.txt的文件 touch aa.txt 2.2 修改文件内容 vi 或 vim打开文件命令：vi 文件名示例：打开当前目录下的aa.txt文件 vi aa.txt 或者 vim aa.txt 注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。 保存或者取消编辑保存文件： 第一步：ESC 进入命令行模式第二步：: 进入底行模式第三步：wq 保存并退出编辑 取消编辑： 第一步：ESC 进入命令行模式第二步：: 进入底行模式第三步：q! 撤销本次修改并退出编辑 2.3 文件的查看文件的查看命令：cat/more/less/tail tail：指定行数或者动态查看 示例：使用tail -n 10 查看sudo.conf文件的后10行，Ctrl+C结束tail -n 10 sudo.conf 示例：使用tail -f 动态查看sudo.conf文件的最新状态（可用于查看日志），Ctrl+C结束tail -f sudo.conf 三、压缩文件操作3.1 打包和压缩命令：tar -zcvf 打包压缩后的文件名 要打包的文件其中：z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tartar -zcvf ab.tar aa.txt bb.txt或：tar -zcvf ab.tar * 3.2 解压命令：tar [-zxvf] 压缩文件其中：x：代表解压示例：将/usr/tmp 下的ab.tar 解压到当前目录下tar -zxvf ab.tar 示例：将/usr/tmp 下的ab.tar解压到根目录/usr下tar -zxvf ab.tar -C /usr -C代表指定解压的位置 四、查找命令4.1 grep查看服务进程 (常用，在服务重启时，用于查询服务的pid，再使用 kill 停止服务)命令 : ps - ef | grep 进程名称 结束进程：kill命令：kill pid 或者 kill -9 pid(强制杀死进程) pid:进程号 4.2 findfind命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。 使用实例： 12345find . -name \"*.log\" -ls 在当前目录查找以.log结尾的文件，并显示详细信息。 find /root/ -perm 600 查找/root/目录下权限为600的文件 find . -type f -name \"*.log\" 查找当目录，以.log结尾的普通文件 find . -type d | sort 查找当前所有目录并排序 find . -size +100M 查找当前目录大于100M的文件 4.3 whereiswhereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。 使用实例： 1whereis ls 将和ls文件相关的文件都查找出来 五、时间设置5.1 安装npt1yum -y install ntp ntpdate 5.2 自动同步时间npt配置文件 1vim /etc/ntp.conf 12345678# 新增-内网的时间服务器地址server 192.168.31.223 prefer# Use public servers from the pool.ntp.org project.# Please consider joining the pool (http://www.pool.ntp.org/join.html).server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburst NTP同步服务 123systemctl start ntpd ## 启动服务 systemctl stop ntpd ## 关闭服务 systemctl status ntpd ## 查看crontab服务状态 查看时间同步结果：ntpstat 123[root@wang01 ~]# ntpstatunsynchronised polling server every 64 s 同步失败,同步也需要时间嘛，需等待一段再次查询 5.3 手动时间同步1ntpdate 0.centos.pool.ntp.org ## 时间服务器地址 六、防火墙6.1 防火墙操作启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalld 6.2 开放指定端口firewall-cmd –zone=public –add-port=80/tcp –permanent //开放端口firewall-cmd –reload //重新载入，使其生效 6.3 关闭指定端口firewall-cmd –zone=public –remove-port=80/tcp –permanent //关闭端口firewall-cmd –reload //重新载入，使其生效 6.4 查看端口状态firewall-cmd –zone=public –query-port=80/tcp //查看端口状态 七、系统操作7.1 域名映射 (Hosts)/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。 123456[root@wang01 /]# vi /etc/hosts#### 将ip与指定域名对应127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain652.201.142.14 registry-1.docker.io192.168.159.100 wang01 7.2 挂盘查看磁盘信息 命令 : fdisk -l 123456789101112131415161718192021222324[root@wang01 jdk1.8.0_221]# fdisk -l磁盘 /dev/sda：53.7 GB, 53687091200 字节，104857600 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x000df63b 设备 Boot Start End Blocks Id System/dev/sda1 * 2048 411647 204800 83 Linux/dev/sda2 411648 25593855 12591104 8e Linux LVM/dev/sda3 25593856 104857599 39631872 8e Linux LVM磁盘 /dev/mapper/centos-root：51.3 GB, 51321503744 字节，100237312 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘 /dev/mapper/centos-swap：2147 MB, 2147483648 字节，4194304 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节 存储信息 命令 : df -h 12345678文件系统 容量 已用 可用 已用% 挂载点devtmpfs 1.4G 0 1.4G 0% /devtmpfs 1.4G 0 1.4G 0% /dev/shmtmpfs 1.4G 11M 1.4G 1% /runtmpfs 1.4G 0 1.4G 0% /sys/fs/cgroup/dev/mapper/centos-root 48G 32G 17G 66% //dev/sda1 197M 167M 31M 85% /boottmpfs 283M 40K 283M 1% /run/user/0 7.3 yum 下载源修改当计算机没连接到外网，使用yum下载资源，需要将下载源改为局域网内才可以下载 命令 : vim /etc/yum.repos.d/xxx.repo 文件名称必须以repo结尾,打开此目录，编辑xxx.repo文件，xxx名字任意，但是最好起规范一点 配置详情： 12345[rhel7.2] #仓库名称name=rhel7.2 source #对软件源的描述baseurl=http:172.25.254.250/rhel7.2/x86_64/dvd #网络安装源gpgcheck=0 #不检测gpgkeyenable=1 #此安装源语句块生效 清空系统原有的yum缓存 1yum clean all 更新yum配置 1yum repolist 7.4 定时任务 (crontab)crontab 安装1yum install crontabs 服务操作说明12345systemctl start crond ## 启动服务 systemctl stop crond ## 关闭服务 systemctl restart crond ## 重启服务 systemctl enable crond ## 开机自启动systemctl status crond ## 查看crontab服务状态 crontab命令编辑定时任务的两种方法：1)、在命令行输入: crontab -e 然后添加相应的任务，wq存盘退出。2)、直接编辑/etc/crontab 文件，即vi /etc/crontab，添加相应的任务。crontab -e配置是针对某个用户的，而编辑/etc/crontab是针对系统的任务 3)、进入编辑状态后的配置说明命令： * * * * * command解释：分 时 日 月 周 命令 1234567891011第1列表示分钟1～59 每分钟用*或者 */1表示 第2列表示小时0～23（0表示0点）第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 4)、配置实例： 12# 进入编辑状态crontab -e 1234567891011121314151617#每分钟执行一次date命令 */1 * * * * date &gt;&gt; /root/date.txt #每晚的21:30重启apache。 30 21 * * * service httpd restart #每月1、10、22日的4 : 45重启apache。 45 4 1,10,22 * * service httpd restart #每周六、周日的1 : 10重启apache。 10 1 * * 6,0 service httpd restart #每天18 : 00至23 : 00之间每隔30分钟重启apache。0,30 18-23 * * * service httpd restart#晚上11点到早上7点之间，每隔一小时重启apache* 23-7/1 * * * service httpd restart 查看调度任务crontab -l //列出当前的所有调度任务crontab -l -u jp //列出用户jp的所有调度任务 删除任务调度工作crontab -r //删除所有任务调度工作 7.5 系统版本查看本文指令基于 centos 7.x 版本，如有命令问题，可先排除版本是否不一致命令 : cat /etc/redhat-release 1CentOS Linux release 7.8.2003 (Core) 7.6 cpu使用情况命令 : top 12345678910111213141516[root@wang01 yum.repos.d]# toptop - 14:45:07 up 1 day, 4:27, 3 users, load average: 0.01, 0.04, 0.05Tasks: 205 total, 1 running, 202 sleeping, 2 stopped, 0 zombie%Cpu(s): 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 2895252 total, 530652 free, 1280236 used, 1084364 buff/cacheKiB Swap: 2097148 total, 2097148 free, 0 used. 1386784 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1838 mysql 20 0 1336196 384924 14712 S 0.3 13.3 7:02.93 mysqld 19444 root 20 0 162124 2348 1588 R 0.3 0.1 0:00.39 top 1 root 20 0 125856 4352 2628 S 0.0 0.2 0:01.94 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 4 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 5 root 20 0 0 0 0 S 0.0 0.0 0:01.53 kworker/u256:0 6 root 20 0 0 0 0 S 0.0 0.0 0:00.68 ksoftirqd/0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 字段说明 123456789%us：表示用户空间程序的cpu使用率（没有通过nice调度）%sy：表示系统空间的cpu使用率，主要是内核程序。%ni：表示用户空间且通过nice调度过的程序的cpu使用率。%id：空闲cpu%wa：cpu运行时在等待io的时间%hi：cpu处理硬中断的数量%si：cpu处理软中断的数量%st：被虚拟机偷走的cpu注：99.0 id，表示空闲CPU，即CPU未使用率，100%-99.0%=1%，即系统的cpu使用率为1%。 123456789101112PID：进程标示号USER：进程所有者PR：进程优先级NI：进程优先级别数值VIRT：进程占用的虚拟内存值RES：进程占用的物理内存值SHR ：进程使用的共享内存值S ：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死%CPU ：进程占用的CPU使用率%MEM ：进程占用的物理内存百分比TIME+：进程启动后占用的总的CPU时间Command：进程启动的启动命令名称 7.7 内存使用情况命令 : free 1234[root@wang01 jdk1.8.0_221]# free -h total used free shared buff/cache availableMem: 2.8G 1.3G 162M 38M 1.3G 1.2GSwap: 2.0G 0B 2.0G 字段说明 12345total：总计物理内存的大小used：已使用多大free：可用有多少Shared：多个进程共享的内存总额Buffers/cached：磁盘缓存的大小 7.8 磁盘文件大小情况命令 : du 123456789101112131415# 显示当前文件夹下的文件大小，-s : 不显示子文件夹情况; -h : 自动转换单位; sort : 将结果排序[root@wang01 opt]# du -sh .[!.]* * | sort -hrdu: 无法访问\".[!.]*\": 没有那个文件或目录 # .[!.]* ： 指包含隐藏文件夹16G bigDataProject2.7G myjava209M myjavacode193M Python-3.7.031M scala-2.11.828M scala-2.11.8.tgz25M application22M Python-3.7.0.tgz0 rh0 fs0 containerd0 bigDataProject 八、JDK离线安装8.1 进入要安装的目录cd 指定目录 8.2 创建 jdk 文件夹mkdir jdk 将安装包上传到该文件夹 8.3 解压安装包1234tar -zxvf jdk-8u211-linux-x64.tar.gz[root@wang01 myjava]# cd jdk1.8.0_221/[root@wang01 jdk1.8.0_221]# pwd/opt/myjava/jdk1.8.0_221 8.4 配置环境变量vim /etc/profile 在最后面填入下面信息，文件目录与上面对应 1234export JAVA_HOME=/opt/myjava/jdk1.8.0_221export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATH 8.5 刷新环境变量文件source /etc/profile 8.6 查看是否安装成功1234[root@wang01 jdk1.8.0_221]# java -versionjava version \"1.8.0_221\"Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 九、docker的简单实用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#查看镜像docker images#搜索镜像docker search xxx#拉取镜像docker pull xxx:x.x#删除镜像docker rmi 镜像ID#删除所有镜像docker rmi `docker images -q`#查看运行的容器docker ps#查看所有容器docker ps -a#查看最后一次运行的容器docker ps -l#查看停止的容器docker ps -f status=exited#交互方式启动容器（exit后关闭）docker run -it --name=mycentos centos:7 /bin/bash#守护方式启动容器（后台运行）docker run -id --name=mycentos2 centos:7#进入守护式容器docker exec -it mycentos2 /bin/bash#容器停止docker stop 容器ID/容器NAME#启动停止的容器docker start 容器ID/容器NAME#文件拷贝docker cp 文件名 mycentos2:/usr/localdocker cp mycentos2:/usr/local/文件名 拷出后文件名#目录挂载docker run -id --name=mycentos3 -v /usr/local/myhtml(宿主机目录):/usr/local/myhtml(容器目录) centos:7#查看容器信息docker inspect mycentos3#查看容器ipdocker inspect --format='&#123; &#123;.NetworkSettings.IPAddress&#125; &#125;' mycentos3#删除容器(先停止容器)docker rm mycentos3","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"油猴脚本接口爬虫","slug":"油猴脚本接口爬虫","date":"2019-12-15T02:49:51.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/12/15/油猴脚本接口爬虫/","link":"","permalink":"https://summercat7.github.io/2019/12/15/油猴脚本接口爬虫/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match https://www.wang.cn/*// @grant GM_xmlhttpRequest// @grant GM_download// ==/UserScript==(function() &#123; 'use strict'; // Your code here... let timestamp=new Date().getTime(); let context = \"\" ft(10) function ft(i) &#123; let timestamp=new Date().getTime(); let base_url = \"https://www.wang.cn?_=\" + timestamp; let da = &#123;\"list\":[\"123\"]&#125; // console.log(da); GM_xmlhttpRequest(&#123; method: \"POST\", url: base_url, headers: &#123; 'Accept': '*/*', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cache-Control': 'no-cache', 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36', 'X-Requested-With': 'XMLHttpRequest' &#125;, dataType: \"json\", data: da, onload: function(response)&#123; //console.log(\"请求成功\"); console.log(response.responseText); let text = response.responseText; if (!text['errors']) &#123; context += (response.responseText+\";\") &#125; if(i==1067) &#123; writeFile(\"2.txt\",context,) &#125; //else &#123; // ft(i+1); //&#125; &#125;, onerror: function(response)&#123; console.log(\"请求失败\"); &#125; &#125;); &#125; //writeFile(\"2.txt\",context,) // 导出文件 function writeFile(fileName, content)&#123; var a= document.createElement('a'); var blob = new Blob([content],&#123;type:'text/plain'&#125;); a.download = fileName; a.href = URL.createObjectURL(blob); a.click() &#125;&#125;)();","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"SpringCloud_高可用的分布式配置中心","slug":"SpringCloud-高可用的分布式配置中心","date":"2019-10-11T12:14:10.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud-高可用的分布式配置中心/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud-高可用的分布式配置中心/","excerpt":"","text":"高可用的分布式配置中心 配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用 准备工作 使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。 在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-eureka-server 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置 1234567891011server: port: 8889eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 入口类： 12345678@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 改造config-server pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-eureka 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件application.properties，指定服务注册地址为http://localhost:8889/eureka/ 123456789spring.application.name=config-serverserver.port=8888spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/spring.cloud.config.server.git.searchPaths=respospring.cloud.config.label=masterspring.cloud.config.server.git.username= your usernamespring.cloud.config.server.git.password= your passwordeureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/ 入口类 12345678910@SpringBootApplication@EnableConfigServer@EnableEurekaClientpublic class ConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServiceApplication.class, args); &#125;&#125; 改造config-client 将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-eureka 1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为http://localhost:8889/eureka/ 123456789spring.application.name=config-clientspring.cloud.config.label=masterspring.cloud.config.profile=dev#spring.cloud.config.uri= http://localhost:8888/eureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/spring.cloud.config.discovery.enabled=truespring.cloud.config.discovery.serviceId=config-serverserver.port=8881 spring.cloud.config.discovery.enabled 是从配置中心读取文件。 spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。 在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。 依次启动eureka-servr,config-server,config-client 访问网址：http://localhost:8889/ 访问http://localhost:8881/hi，浏览器显示： foo version 3","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud_config","slug":"SpringCloud-config","date":"2019-10-11T12:13:03.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud-config/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud-config/","excerpt":"","text":"config简介 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 构建Config Server 创建一个spring-boot项目，取名为config-server 引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能 12345678@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; 需要在程序的配置文件application.properties文件配置以下 123456789spring.application.name=config-serverserver.port=8888spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/spring.cloud.config.server.git.searchPaths=respospring.cloud.config.label=masterspring.cloud.config.server.git.username=your usernamespring.cloud.config.server.git.password=your password spring.cloud.config.server.git.uri：配置git仓库地址 spring.cloud.config.server.git.searchPaths：配置仓库路径 spring.cloud.config.label：配置仓库的分支 spring.cloud.config.server.git.username：访问git仓库的用户名 spring.cloud.config.server.git.password：访问git仓库的用户密码 如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写 启动程序：访问http://localhost:8888/foo/dev http请求地址和资源文件映射如下: /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 构建一个config client 重新创建一个springboot项目，取名为config-client 引入依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置文件12345spring.application.name=config-clientspring.cloud.config.label=masterspring.cloud.config.profile=devspring.cloud.config.uri= http://localhost:8888/server.port=8881 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 入口类 程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值 123456789101112131415@SpringBootApplication@RestControllerpublic class ConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication.class, args); &#125; @Value(\"$&#123;foo&#125;\") String foo; @RequestMapping(value = \"/hi\") public String hi()&#123; return foo; &#125;&#125; 打开网址访问：http://localhost:8881/hi，网页显示： foo version 3 这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud_zuul","slug":"SpringCloud-zuul","date":"2019-10-11T12:12:09.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud-zuul/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud-zuul/","excerpt":"","text":"Zuul简介 Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。 zuul有以下功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 准备工作 在原有的工程上，创建一个新的工程。 创建service-zuul工程 引入依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能 12345678@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class ServiceZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceZuulApplication.class, args); &#125;&#125; 加上配置文件application.yml加上以下的配置代码 1234567891011121314151617eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8769spring: application: name: service-zuulzuul: routes: api-a: path: /api-a/** serviceId: service-ribbon api-b: path: /api-b/** serviceId: service-feign 首先指定服务注册中心的地址为http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务； 依次运行这五个工程;打开浏览器访问：http://localhost:8769/api-a/hi?name=wang ;浏览器显示： hi wang,i am from port:8762 打开浏览器访问：http://localhost:8769/api-b/hi?name=wang ;浏览器显示： hi wang,i am from port:8762 这说明zuul起到了路由的作用 服务过滤 zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程: 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class MyFilter extends ZuulFilter&#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return \"pre\"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\"%s &gt;&gt;&gt; %s\", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\"token\"); if(accessToken == null) &#123; log.warn(\"token is empty\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write(\"token is empty\"); &#125;catch (Exception e)&#123;&#125; return null; &#125; log.info(\"ok\"); return null; &#125;&#125; filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 1234这时访问：http://localhost:8769/api-a/hi?name=wang ；网页显示： token is empty访问 http://localhost:8769/api-a/hi?name=wang&amp;token=22 ； 网页显示： hi wang,i am from port:8762","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud_hystrix","slug":"SpringCloud-hystrix","date":"2019-10-11T12:09:48.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud-hystrix/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud-hystrix/","excerpt":"","text":"hystrixribbon中使用断路器概述 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 准备工作 启动eureka-server 工程；启动service-hi工程，它的端口为8762。 在ribbon使用断路器 改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix 12345678910111213141516@SpringBootApplication@EnableDiscoveryClient@EnableHystrixpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串 123456789101112131415@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"hiError\") public String hiService(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class); &#125; public String hiError(String name) &#123; return \"hi,\"+name+\",sorry,error!\"; &#125;&#125; 启动：service-ribbon 工程，当我们访问http://localhost:8764/hi?name=wang,浏览器显示： hi wang,i am from port:8762 此时关闭 service-hi 工程，当我们再访问http://localhost:8764/hi?name=wang，浏览器会显示： hi ,wang,orry,error! Feign中使用断路器 Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它 1feign.hystrix.enabled=true 基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类 12345@FeignClient(value = \"service-hi\",fallback = SchedualServiceHiHystric.class)public interface SchedualServiceHi &#123; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中 1234567@Componentpublic class SchedualServiceHiHystric implements SchedualServiceHi &#123; @Override public String sayHiFromClientOne(String name) &#123; return \"sorry \"+name; &#125;&#125; 运行效果同上 Hystrix Dashboard (断路器：Hystrix 仪表盘) 基于service-ribbon 改造，Feign的改造和这一样。 首选在pom.xml引入spring-cloud-starter-hystrix-dashboard的起步依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在主程序启动类中加入@EnableHystrixDashboard注解，开启hystrixDashboard 1234567891011121314151617@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableHystrixDashboardpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 打开浏览器：访问http://localhost:8764/hystrix 点击monitor stream，进入下一个界面，访问：http://localhost:8764/hi?name=forezp 此时会出现监控界面","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud_feign","slug":"SpringCloud-feign","date":"2019-10-11T12:07:23.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud-feign/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud-feign/","excerpt":"","text":"Feign简介 Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 简而言之： Feign 采用的是基于接口的注解 Feign 整合了ribbon 准备工作 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web 创建项目 引入依赖 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8765spring: application: name: service-feign 在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口 12345@FeignClient(value = \"service-hi\")public interface SchedualServiceHi &#123; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; 在Web层的controller层，对外暴露一个”/hi”的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务 12345678910@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 在浏览器上多次访问http://localhost:8765/hi?name=wang，浏览器交替显示： hi wang,i am from port:8762 hi wang,i am from port:8763","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud_ribbon","slug":"SpringCloud_ribbon","date":"2019-10-11T12:04:34.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud_ribbon/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud_ribbon/","excerpt":"","text":"ribbon用途 在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。 简介 ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。 ribbon 已经默认实现了这些配置bean： IClientConfig ribbonClientConfig: DefaultClientConfigImpl IRule ribbonRule: ZoneAvoidanceRule IPing ribbonPing: NoOpPing ServerList ribbonServerList: ConfigurationBasedServerList ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer 准备工作 基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。 建一个服务消费者 引入依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8764spring: application: name: service-ribbon 在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册； 向程序的ioc注入一个bean: restTemplate; 通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。 123456789101112131415@SpringBootApplication@EnableDiscoveryClientpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下： 1234567891011@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; public String hiService(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class); &#125;&#125; 写一个controller，在controller中用调用HelloService 的方法，代码如下： 12345678910@RestControllerpublic class HelloControler &#123; @Autowired HelloService helloService; @RequestMapping(value = \"/hi\") public String hi(@RequestParam String name)&#123; return helloService.hiService(name); &#125;&#125; 在浏览器上多次访问http://localhost:8764/hi?name=wang，浏览器交替显示： hi wang,i am from port:8762 hi wang,i am from port:8763","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringCloud入门1：创建工程","slug":"SpringCloud入门1：创建工程","date":"2019-10-11T00:37:02.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/11/SpringCloud入门1：创建工程/","link":"","permalink":"https://summercat7.github.io/2019/10/11/SpringCloud入门1：创建工程/","excerpt":"","text":"SpringCloud入门SpringCloud简介 spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。 spring cloud是基于springboot的。项目创建 右键工程-&gt;创建model-&gt; 选择spring initialir 下一步-&gt;选择cloud discovery-&gt;eureka server EurekaServer 只需要一个注解@EnableEurekaServer 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaserverApplication.class, args); &#125;&#125; eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server appication.yml 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ EurekaClient 注解@EnableEurekaClient 表明自己是一个eurekaclient 123456789101112131415@SpringBootApplication@EnableEurekaClient@RestControllerpublic class ServiceHiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceHiApplication.class, args); &#125; @Value(\"$&#123;server.port&#125;\") String port; @RequestMapping(\"/hi\") public String home(@RequestParam String name) &#123; return \"hi \"+name+\",i am from port:\" +port; &#125;&#125; application.yml 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8762spring: application: name: service-hi","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门6：整合redis","slug":"SpringBoot入门6：整合redis","date":"2019-10-10T06:30:38.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/10/SpringBoot入门6：整合redis/","link":"","permalink":"https://summercat7.github.io/2019/10/10/SpringBoot入门6：整合redis/","excerpt":"","text":"SpringBoot整合redis引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据源1234567891011spring: redis: host: localhost port: 6379 database: 1 timeout: 5000 pool: max-active: 8 max-wait: -1 max-idle: 500 min-idle: 0 Dao层12345678910111213141516@Repositorypublic class RedisDao &#123; @Autowired private StringRedisTemplate template; public void setKey(String key,String value)&#123; ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期 &#125; public String getValue(String key)&#123; ValueOperations&lt;String, String&gt; ops = this.template.opsForValue(); return ops.get(key); &#125;&#125; 单元测试12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; public static Logger logger= LoggerFactory.getLogger(SpringbootRedisApplicationTests.class); @Test public void contextLoads() &#123; &#125; @Autowired RedisDao redisDao; @Test public void testRedis()&#123; redisDao.setKey(\"name\",\"wang\"); redisDao.setKey(\"age\",\"18\"); logger.info(redisDao.getValue(\"name\")); logger.info(redisDao.getValue(\"age\")); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门5：整合mybatis","slug":"SpringBoot入门5：整合mybatis","date":"2019-10-10T06:15:24.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/10/SpringBoot入门5：整合mybatis/","link":"","permalink":"https://summercat7.github.io/2019/10/10/SpringBoot入门5：整合mybatis/","excerpt":"","text":"SpringBoot整合mybatis引入依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置数据源使用注解123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC username: root password: root 使用xml123456spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.mapper-locations=classpath*:mybatis/*Mapper.xmlmybatis.type-aliases-package=com.forezp.entity Dao层使用注解1234567891011121314151617@Mapperpublic interface AccountDao &#123; @Insert(\"insert into account(name,money) value(#&#123;name&#125;,#&#123;money&#125;)\") public int add(@Param(\"name\") String name, @Param(\"money\") double money); @Update(\"update account set name = #&#123;name&#125;, money = #&#123;money&#125; where id = #&#123;id&#125;\") int update(@Param(\"name\") String name, @Param(\"money\") double money, @Param(\"id\") int id); @Delete(\"delete from account where id = #&#123;id&#125;\") int delete(int id); @Select(\"select id, name, money from account where id = #&#123;id&#125;\") Account findAccount(@Param(\"id\") int id); @Select(\"select id, name, money from account\") List&lt;Account&gt; findAccountList();&#125; 使用xml 接口 123public interface AccountMapper2 &#123; int update( @Param(\"money\") double money, @Param(\"id\") int id);&#125; mapper 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.forezp.dao.AccountMapper2\"&gt; &lt;update id=\"update\"&gt; UPDATE account set money=#&#123;money&#125; WHERE id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; service层1234567891011121314@Servicepublic class AccountService2 &#123; @Autowired AccountMapper2 accountMapper2; //使用声明式事务 @Transactional public void transfer() throws RuntimeException&#123; accountMapper2.update(90,1);//用户1减10块 用户2加10块 int i=1/0; accountMapper2.update(110,2); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门4：JPA","slug":"SpringBoot入门4：JPA","date":"2019-10-09T11:32:04.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/09/SpringBoot入门4：JPA/","link":"","permalink":"https://summercat7.github.io/2019/10/09/SpringBoot入门4：JPA/","excerpt":"","text":"JPA概述 JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。 JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。 实现添加相关依赖 添加spring-boot-starter-jdbc依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa &lt;/artifactId&gt;&lt;/dependency&gt; 添加mysql连接类和连接池类： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置数据源，在application.properties文件配置：1234567891011spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8 username: root password: 123456 jpa: hibernate: ddl-auto: update # 第一次简表create 后面用update show-sql: true 注意，如果通过jpa在数据库中建表，将jpa.hibernate,ddl-auto改为create，建完表之后，要改为update,要不然每次重启工程会删除表并新建。实体类 通过@Entity 表明是一个映射的实体类， @Id表明id， @GeneratedValue 字段自动生成12345678@Entitypublic class Account &#123; @Id @GeneratedValue private int id ; private String name ; private double money;&#125; DAO层 数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long12public interface AccountDao extends JpaRepository&lt;Account,Integer&gt; &#123;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringBoot入门3：JDBCTemplate","slug":"SpringBoot入门3：JDBCTemplate","date":"2019-10-09T09:08:33.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/09/SpringBoot入门3：JDBCTemplate/","link":"","permalink":"https://summercat7.github.io/2019/10/09/SpringBoot入门3：JDBCTemplate/","excerpt":"","text":"JDBCTemplate创建工程引入依赖：在pom文件引入spring-boot-starter-jdbc的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 引入mysql连接类和连接池：1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 开启web:1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置相关文件在application.properties文件配置mysql的驱动类，数据库地址，数据库账号、密码信息。 1234spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?serverTimezone=UTCspring.datasource.username=usernamespring.datasource.password=password 具体代码Dao实现类12345678910111213141516171819202122232425262728293031323334353637383940414243@Repositorypublic class AccountDaoImpl implements IAccountDAO &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(Account account) &#123; String sql = \"insert into account(name,money) value(?,?)\"; return jdbcTemplate.update(sql,account.getName(),account.getMoney()); &#125; @Override public int update(Account account) &#123; String sql = \"update account set name=?,money=? where id=?\"; return jdbcTemplate.update(sql,account.getName(),account.getMoney(),account.getId()); &#125; @Override public int delete(int id) &#123; String sql = \"delete from teble account where id=?\"; return jdbcTemplate.update(sql,id); &#125; @Override public Account findAccountById(int id) &#123; String sql = \"select * from account where id=?\"; List&lt;Account&gt; list = jdbcTemplate.query(sql, new Object[]&#123;id&#125;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); if (list!=null &amp;&amp; list.size()&gt;0) &#123; return list.get(0); &#125; else &#123; return null; &#125; &#125; @Override public List&lt;Account&gt; findAccountList() &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account\", new Object[]&#123;&#125;, new BeanPropertyRowMapper(Account.class)); if(list!=null &amp;&amp; list.size()&gt;0)&#123; return list; &#125;else&#123; return null; &#125; &#125;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RestController@RequestMapping(\"/account\")public class AccountController &#123; @Autowired IAccountService accountService; @RequestMapping(value = \"/list\",method = RequestMethod.GET) public List&lt;Account&gt; getAccounts()&#123; return accountService.findAccountList(); &#125; @RequestMapping(value = \"/&#123;id&#125;\",method = RequestMethod.GET) public Account getAccountById(@PathVariable(\"id\") int id)&#123; return accountService.findAccountById(id); &#125; @RequestMapping(value = \"/&#123;id&#125;\",method = RequestMethod.PUT) public String updateAccount(@PathVariable(\"id\")int id , @RequestParam(value = \"name\",required = true)String name, @RequestParam(value = \"money\" ,required = true)double money)&#123; Account account=new Account(); account.setMoney(money); account.setName(name); account.setId(id); int t=accountService.update(account); if(t==1)&#123; return account.toString(); &#125;else &#123; return \"fail\"; &#125; &#125; @RequestMapping(value = \"\",method = RequestMethod.POST) public String postAccount( @RequestParam(value = \"name\")String name, @RequestParam(value = \"money\" )double money)&#123; Account account=new Account(); account.setMoney(money); account.setName(name); int t= accountService.add(account); if(t==1)&#123; return account.toString(); &#125;else &#123; return \"fail\"; &#125; &#125;&#125; 可以通过postman来测试","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringBoot入门2：配置文件","slug":"SpringBoot入门2：配置文件","date":"2019-10-09T07:49:53.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/09/SpringBoot入门2：配置文件/","link":"","permalink":"https://summercat7.github.io/2019/10/09/SpringBoot入门2：配置文件/","excerpt":"","text":"配置文件自定义属性 如果你需要读取配置文件的值只需要加@Value(“${属性名}”) 将配置文件的属性赋给实体类12345678my: name: forezp age: 12 number: $&#123;random.int&#125; uuid : $&#123;random.uuid&#125; max: $&#123;random.int(10)&#125; value: $&#123;random.value&#125; greeting: hi,i'm $&#123;my.name&#125; javabean123456789101112@ConfigurationProperties(prefix = \"my\")@Componentpublic class ConfigBean &#123; private String name; private int age; private int number; private String uuid; private int max; private String value; private String greeting;&#125; spring-boot-configuration-processor依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 应用类1234567891011@RestController@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)public class LucyController &#123; @Autowired ConfigBean configBean; @RequestMapping(\"/lucy\") public String miya() &#123; return configBean.getGreeting()+\" &gt;&gt;&gt;&gt;\"+configBean.getName()+\" &gt;&gt;&gt;&gt;\"+ configBean.getUuid()+\" &gt;&gt;&gt;&gt;\"+configBean.getMax(); &#125;&#125; 自定义配置文件test.properties12com.wang.name=wangcom.wang.age=12 javaBean 在最新版本的springboot，需要加这三个注解。@Configuration @PropertySource(value = “classpath:test.properties”) @ConfigurationProperties(prefix = “com.forezp”);在1.4版本需要 PropertySource加上location。1234567891011121314151617181920212223@Configuration@PropertySource(\"test.properties\")@ConfigurationProperties(\"com.wang\")public class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 应用类123456789101112131415161718@RestController@EnableConfigurationProperties(&#123;ConfigBean.class,User.class&#125;)public class LucyController &#123; @Autowired ConfigBean configBean; @RequestMapping(\"/lucy\") public String miya() &#123; return configBean.getGreeting()+\" &gt;&gt;&gt;&gt;\"+configBean.getName()+\" &gt;&gt;&gt;&gt;\"+ configBean.getUuid()+\" &gt;&gt;&gt;&gt;\"+configBean.getMax(); &#125; @Autowired User user; @RequestMapping(\"/user\") public String user() &#123; return user.getName()+\"&gt;&gt;&gt;&gt;\"+user.getAge(); &#125;&#125; 多个环境配置文件 application-test.properties：测试环境 application-dev.properties：开发环境 application-prod.properties：生产环境 使用方法 application.yml 123spring: profiles: active: dev application-dev.yml 12server: port: 8082","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringBoot入门1：创建工程","slug":"SpringBoot入门1：创建工程","date":"2019-10-09T06:30:43.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/10/09/SpringBoot入门1：创建工程/","link":"","permalink":"https://summercat7.github.io/2019/10/09/SpringBoot入门1：创建工程/","excerpt":"","text":"构建springboot工程创建项目 打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。目录结构 pom文件为基本的依赖管理文件 resouces 资源文件 statics 静态资源 templates 模板资源 application.yml 配置文件 SpringbootApplication程序的入口。启动springboot 方式 cd到项目主目录: mvn clean mvn package 编译项目的jar mvn spring-boot: run 启动 cd 到target目录，java -jar 项目.jar单元测试 通过@RunWith() @SpringBootTest开启注解123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloControllerIT &#123; @LocalServerPort private int port; private URL base; @Autowired private TestRestTemplate template; @Before public void setUp() throws Exception &#123; this.base = new URL(\"http://localhost:\" + port + \"/\"); &#125; @Test public void getHello() throws Exception &#123; ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo(\"Greetings from Spring Boot!\")); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"ssm框架整合","slug":"ssm框架整合","date":"2019-09-15T14:35:31.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/09/15/ssm框架整合/","link":"","permalink":"https://summercat7.github.io/2019/09/15/ssm框架整合/","excerpt":"","text":"ssm框架整合步骤* 1. 先搭建整合的环境 * 2. 先把Spring的配置搭建完成 * 3. 再使用Spring整合SpringMVC框架 * 4. 最后使用Spring整合MyBatis框架数据库1234567create database ssm;use ssm;create table account( id int primary key auto_increment, name varchar(20), money double); pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;web-app&gt;&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--设置配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动服务器，创建该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架去管理 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt; &lt;!-- 配置要忽略的注解 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--Spring整合MyBatis框架--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssm\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置AccountDao接口所在包--&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.wang.dao\"/&gt; &lt;/bean&gt; &lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" isolation=\"DEFAULT\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* cn.wang.service.impl.*ServiceImpl.*(..))\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 扫描controller的注解，别的不扫描 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- JSP文件所在的目录 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\" /&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\" /&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\" /&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\" /&gt; &lt;!-- 开启对SpringMVC注解的支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; dao12345678910@Repositorypublic interface AccountDao &#123; //查询所有账户 @Select(\"select * from account\") public List&lt;Account&gt; findAll(); //保存账户信息 @Insert(\"insert into account (name,money) value(#&#123;name&#125;,#&#123;money&#125;)\") public void saveAccount(Account account);&#125; ServiceImpl1234567891011121314151617@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao dao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"业务层：查询所有\"); return dao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"业务层：保存帐户\"); dao.saveAccount(account); &#125;&#125; Controller123456789101112131415161718192021@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model) &#123; System.out.println(\"表现层：查询所有\"); List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\",list); return \"list\"; &#125; @RequestMapping(\"/save\") public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+\"/account/findAll\"); return ; &#125;&#125; index.jsp1234567&lt;a href=\"account/findAll\"&gt;测试&lt;/a&gt;&lt;form action=\"account/save\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\" /&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; list.jsp12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查询所有账户&lt;/h3&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"account\"&gt; $&#123;account.name&#125; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringMVC入门4","slug":"SpringMVC入门4","date":"2019-09-14T13:38:55.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/09/14/SpringMVC入门4/","link":"","permalink":"https://summercat7.github.io/2019/09/14/SpringMVC入门4/","excerpt":"","text":"异常处理和拦截器 异常处理器异常处理思路 Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进行异常的处理。自定义异常类1234567891011121314public class SysException extends Exception&#123; private static final long serialVersionUID = 4055945147128016300L; // 异常提示信息 private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器12345678910111213141516171819202122232425/*** 异常处理器* @author rt*/public class SysExceptionResolver implements HandlerExceptionResolver&#123;/*** 跳转到具体的错误页面的方法*/public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,Exception ex) &#123; ex.printStackTrace(); SysException e = null; // 获取到异常对象 if(ex instanceof SysException) &#123; e = (SysException) ex; &#125;else &#123; e = new SysException(\"请联系管理员\"); &#125; ModelAndView mv = new ModelAndView(); // 存入错误的提示信息 mv.addObject(\"message\", e.getMessage()); // 跳转的Jsp页面 mv.setViewName(\"error\"); return mv; &#125;&#125; 配置异常处理器12&lt;!-- 配置异常处理器 --&gt;&lt;bean id=\"sysExceptionResolver\" class=\"cn.itcast.exception.SysExceptionResolver\"/&gt; 拦截器拦截器的概述 SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。 拦截器和过滤器的功能比较类似，有区别 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。 拦截器是SpringMVC框架独有的。 过滤器配置了/*，可以拦截任何资源。 拦截器只会对控制器中的方法进行拦截。 拦截器也是AOP思想的一种实现方式 想要自定义拦截器，需要实现HandlerInterceptor接口。代码实现 创建类，实现HandlerInterceptor接口，重写需要的方法 12345678910111213141516/*** 自定义拦截器1* @author rt*/public class MyInterceptor1 implements HandlerInterceptor&#123; /** * controller方法执行前，进行拦截的方法 * return true放行 * return false拦截 * 可以使用转发或者重定向直接跳转到指定的页面。 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception &#123; System.out.println(\"拦截器执行了...\"); return true; &#125;&#125; 在springmvc.xml中配置拦截器类 123456789101112&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 哪些方法进行拦截 --&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!-- 注册拦截器对象 --&gt; &lt;bean class=\"cn.itcast.demo1.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; HandlerInterceptor接口中的方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 postHandle方法是在JSP执行后执行 request或者response不能再跳转页面了","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringMVC入门3","slug":"SpringMVC入门3","date":"2019-09-14T12:07:24.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/09/14/SpringMVC入门3/","link":"","permalink":"https://summercat7.github.io/2019/09/14/SpringMVC入门3/","excerpt":"","text":"文件上传 普通方式jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 上传页面12345&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action=\"user/fileupload\" method=\"post\" enctype=\"multipart/form-data\"&gt;选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"上传文件\"/&gt;&lt;/form&gt; Controller控制器1234567891011121314151617181920212223242526272829303132333435/*** 文件上传* @throws Exception*/@RequestMapping(value=\"/fileupload\")public String fileupload(HttpServletRequest request) throws Exception &#123; // 先获取到要上传的文件目录 String path = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 创建File对象，一会向该路径下上传文件 File file = new File(path); // 判断路径是否存在，如果不存在，创建该路径 if(!file.exists()) &#123; file.mkdirs(); &#125; // 创建磁盘文件项工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(factory); // 解析request对象 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历 for (FileItem fileItem : list) &#123; // 判断文件项是普通字段，还是上传的文件 if(fileItem.isFormField()) &#123; &#125;else &#123; // 上传文件项 // 获取到上传文件的名称 String filename = fileItem.getName(); // 上传文件 fileItem.write(new File(file, filename)); // 删除临时文件 fileItem.delete(); &#125; &#125; return \"success\";&#125; SpringMVC传统方式上传文件 SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的name属性名称相同。 代码如下文件解析器12345&lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;&lt;bean id=\"multipartResolver\"class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; Controller控制器123456789101112131415161718192021222324252627/*** SpringMVC方式的文件上传** @param request* @return* @throws Exception*/@RequestMapping(value=\"/fileupload2\")public String fileupload2(HttpServletRequest request,MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC方式的文件上传...\"); // 先获取到要上传的文件目录 String path = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 创建File对象，一会向该路径下上传文件 File file = new File(path); // 判断路径是否存在，如果不存在，创建该路径 if(!file.exists()) &#123; file.mkdirs(); &#125; // 获取到上传文件的名称 String filename = upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); // 把文件的名称唯一化 filename = uuid+\"_\"+filename; // 上传文件 upload.transferTo(new File(file,filename)); return \"success\";&#125; SpringMVC跨服务器上传文件jar包12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 上传页面12345&lt;h3&gt;跨服务器的文件上传&lt;/h3&gt;&lt;form action=\"user/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt;选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"上传文件\"/&gt;&lt;/form&gt; Controller控制器1234567891011121314151617181920212223242526/*** SpringMVC跨服务器方式的文件上传** @param request* @return* @throws Exception*/@RequestMapping(value=\"/fileupload3\")public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC跨服务器方式的文件上传...\"); // 定义图片服务器的请求路径 String path = \"http://localhost:9090/day02_springmvc5_02image/uploads/\"; // 获取到上传文件的名称 String filename = upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); // 把文件的名称唯一化 filename = uuid+\"_\"+filename; // 向图片服务器上传文件 // 创建客户端对象 Client client = Client.create(); // 连接图片服务器 WebResource webResource = client.resource(path+filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\";&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringMVC入门2","slug":"SpringMVC入门2","date":"2019-09-12T13:35:02.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/09/12/SpringMVC入门2/","link":"","permalink":"https://summercat7.github.io/2019/09/12/SpringMVC入门2/","excerpt":"","text":"常用的注解 RequestParam 作用：把请求中的指定名称的参数传递给控制器中的形参赋值 属性 value：请求参数中的名称 required：请求参数中是否必须提供此参数，默认值是true，必须提供 代码如下12345678910/*** 接收请求* @return*/@RequestMapping(path=\"/hello\")public String sayHello(@RequestParam(value=\"username\",required=false)String name) &#123; System.out.println(\"aaaa\"); System.out.println(name); return \"success\";&#125; RequestBody 作用：用于获取请求体的内容（注意：get方法不可以） 属性 required：是否必须有请求体，默认值是true 代码如下12345678910/*** 接收请求* @return*/@RequestMapping(path=\"/hello\")public String sayHello(@RequestBody String body) &#123; System.out.println(\"aaaa\"); System.out.println(body); return \"success\";&#125; PathVariable 作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 属性 value：指定url中的占位符名称 Restful风格的URL 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 代码如下1234567891011&lt;a href=\"user/hello/1\"&gt;入门案例&lt;/a&gt;``` ```java/*** 接收请求* @return*/@RequestMapping(path=\"/hello/&#123;id&#125;\")public String sayHello(@PathVariable(value=\"id\") String id) &#123; System.out.println(id); return \"success\";&#125; RequestHeader 作用：获取指定请求头的值 属性 value：请求头的名称 代码如下12345@RequestMapping(path=\"/hello\")public String sayHello(@RequestHeader(value=\"Accept\") String header) &#123; System.out.println(header); return \"success\";&#125; CookieValue 作用：用于获取指定cookie的名称的值 属性 value：cookie的名称 代码12345@RequestMapping(path=\"/hello\")public String sayHello(@CookieValue(value=\"JSESSIONID\") String cookieValue) &#123; System.out.println(cookieValue); return \"success\";&#125; ModelAttribute 作用 出现在方法上：表示当前方法会在控制器方法执行前线执行。 出现在参数上：获取指定的数据给参数赋值。 应用场景 当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。 具体的代码 修饰的方法有返回值12345678910111213141516171819202122232425/*** 作用在方法，先执行* @param name* @return*/@ModelAttributepublic User showUser(String name) &#123; System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); return user;&#125;/*** 修改用户的方法* @param cookieValue* @return*/@RequestMapping(path=\"/updateUser\")public String updateUser(User user) &#123; System.out.println(user); return \"success\";&#125; 修饰的方法没有返回值12345678910111213141516171819202122232425/*** 作用在方法，先执行* @param name* @return*/@ModelAttributepublic void showUser(String name,Map&lt;String, User&gt; map) &#123; System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); map.put(\"abc\", user);&#125;/*** 修改用户的方法* @param cookieValue* @return*/@RequestMapping(path=\"/updateUser\") public String updateUser(@ModelAttribute(value=\"abc\") User user) &#123; System.out.println(user); return \"success\";&#125; SessionAttributes 作用：用于多次执行控制器方法间的参数共享 属性 value：指定存入属性的名称 代码如下1234567891011121314151617181920212223242526272829303132333435363738@Controller@RequestMapping(path=\"/user\")@SessionAttributes(value= &#123;\"username\",\"password\",\"age\"&#125;,types=&#123;String.class,Integer.class&#125;) // 把数据存入到session域对象中public class HelloController &#123;/*** 向session中存入值* @return*/@RequestMapping(path=\"/save\")public String save(Model model) &#123; System.out.println(\"向session域中保存数据\"); model.addAttribute(\"username\", \"root\"); model.addAttribute(\"password\", \"123\"); model.addAttribute(\"age\", 20); return \"success\";&#125;/*** 从session中获取值* @return*/@RequestMapping(path=\"/find\")public String find(ModelMap modelMap) &#123; String username = (String) modelMap.get(\"username\"); String password = (String) modelMap.get(\"password\"); Integer age = (Integer) modelMap.get(\"age\"); System.out.println(username + \" : \"+password +\" : \"+age); return \"success\";&#125;/*** 清除值* @return*/@RequestMapping(path=\"/delete\")public String delete(SessionStatus status) &#123; status.setComplete(); return \"success\"; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"SpringMVC入门1","slug":"SpringMVC入门1","date":"2019-09-11T07:28:20.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/09/11/SpringMVC入门1/","link":"","permalink":"https://summercat7.github.io/2019/09/11/SpringMVC入门1/","excerpt":"","text":"SpringMVC创建 maven.xml1234567891011121314151617181920212223242526272829303132&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置中文过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC.xml(配置)1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt;&lt;/context:component-scan&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"cn.wang.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt;&lt;!-- 开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;/beans&gt; Controller123456789101112131415161718192021222324252627@Controllerpublic class HelloController &#123; @RequestMapping(path = \"/hello\",params = &#123;&#125;,headers = &#123;&#125;) public String sayHello()&#123; System.out.println(\"Hello\"); return \"success\"; &#125; /** * 原生的API * @return */ @RequestMapping(\"/testServlet\") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(\"执行了...\"); System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext servletContext = session.getServletContext(); System.out.println(servletContext); System.out.println(response); return \"success\"; &#125;&#125; 类型转换器12345678910111213141516171819202122232425/** * 把字符串转换日期 */public class StringToDateConverter implements Converter&lt;String,Date&gt;&#123; /** * String source 传入进来字符串 * @param source * @return */ public Date convert(String source) &#123; // 判断 if(source == null)&#123; throw new RuntimeException(\"请您传入数据\"); &#125; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; // 把字符串转换日期 return df.parse(source); &#125; catch (Exception e) &#123; throw new RuntimeException(\"数据类型转换出现错误\"); &#125; &#125;&#125; json 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门8","slug":"Spring入门8","date":"2019-08-19T12:24:34.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/19/Spring入门8/","link":"","permalink":"https://summercat7.github.io/2019/08/19/Spring入门8/","excerpt":"","text":"Spring(事务控制)使用纯注解 maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 主配置类12345678910/** * spring的配置类，相当于bean.xml */@Configuration@ComponentScan(\"com.itheima\")@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)@PropertySource(\"jdbcConfig.properties\")@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125; jdbc配置类1234567891011121314151617181920212223242526272829303132333435363738394041/** * 和连接数据库相关的配置类 */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; /** * 创建JdbcTemplate * @param dataSource * @return */ @Bean(name=\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name=\"dataSource\") public DataSource createDataSource()&#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(username); ds.setPassword(password); return ds; &#125;&#125; 事务配置类123456789101112131415/** * 和事务相关的配置类 */public class TransactionConfig &#123; /** * 用于创建事务管理器对象 * @param dataSource * @return */ @Bean(name=\"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; service123456789101112131415161718192021222324252627282930313233343536373839404142/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */@Service(\"accountService\")@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService&#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; //需要的是读写型事务配置 @Transactional(propagation= Propagation.REQUIRED,readOnly=false) @Override public void transfer(String sourceName, String targetName, Float money) &#123; System.out.println(\"transfer....\"); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source);// int i=1/0; //2.6更新转入账户 accountDao.updateAccount(target); &#125;&#125; 测试类1234567891011121314/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= SpringConfiguration.class)public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门7","slug":"Spring入门7","date":"2019-08-19T08:06:43.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/19/Spring入门7/","link":"","permalink":"https://summercat7.github.io/2019/08/19/Spring入门7/","excerpt":"","text":"Spring(事务控制)使用注解+xml maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置JdbcTemplate--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/java\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于注解 的声明式事务控制配置步骤 1、配置事务管理器 2、开启spring对注解事务的支持 3、在需要事务支持的地方使用@Transactional注解 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启spring对注解事务的支持--&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; service12345678910111213141516171819202122232425262728293031323334@Service(\"accountService\")@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService&#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; //需要的是读写型事务配置 @Transactional(propagation= Propagation.REQUIRED,readOnly=false) @Override public void transfer(String sourceName, String targetName, Float money) &#123; System.out.println(\"transfer....\"); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source); int i=1/0; //2.6更新转入账户 accountDao.updateAccount(target); &#125;&#125; dao1234567891011121314151617181920212223242526272829@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(\"select * from account where id = ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId); return accounts.isEmpty()?null:accounts.get(0); &#125; @Override public Account findAccountByName(String accountName) &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(\"select * from account where name = ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName); if(accounts.isEmpty())&#123; return null; &#125; if(accounts.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一\"); &#125; return accounts.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\",account.getName(),account.getMoney(),account.getId()); &#125;&#125; 测试类1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门6","slug":"Spring入门6","date":"2019-08-17T09:51:06.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/17/Spring入门6/","link":"","permalink":"https://summercat7.github.io/2019/08/17/Spring入门6/","excerpt":"","text":"Spring(事务控制)使用xml maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置业务层--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置账户的持久层--&gt; &lt;bean id=\"accountDao\" class=\"com.itheima.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/java\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于XML的声明式事务控制配置步骤 1、配置事务管理器 2、配置事务的通知 此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的 使用tx:advice标签配置事务通知 属性： id：给事务通知起一个唯一标识 transaction-manager：给事务通知提供一个事务管理器引用 3、配置AOP中的通用切入点表达式 4、建立事务通知和切入点表达式的对应关系 5、配置事务的属性 是在事务的通知tx:advice标签的内部 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务的属性 isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。 propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。 read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。 timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。 rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类1234567891011121314/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门5","slug":"Spring入门5","date":"2019-08-16T09:30:15.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/16/Spring入门5/","link":"","permalink":"https://summercat7.github.io/2019/08/16/Spring入门5/","excerpt":"","text":"Spring(AOP)使用注解 maven123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt;&lt;/context:component-scan&gt; &lt;bean id=\"logger\" class=\"cn.wang.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置Spring开始注解AOP的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 通知类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component(\"logger\")@Aspect//表示当前类是切面类public class Logger &#123; @Pointcut(\"execution(* cn.wang.service.impl.*.*(..))\") private void pt1()&#123;&#125; /** * 前置通知 */// @Before(\"pt1()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */// @AfterReturning(\"pt1()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */// @AfterThrowing(\"pt1()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */// @After(\"pt1()\") public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pt1()\") public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门4","slug":"Spring入门4","date":"2019-08-15T13:52:19.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/15/Spring入门4/","link":"","permalink":"https://summercat7.github.io/2019/08/15/Spring入门4/","excerpt":"","text":"Spring(AOP)使用xml maven123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置Spring的Ioc，把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"cn.wang.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"logger\" class=\"cn.wang.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--spring中基于XML的AOP配置步骤 1、把通知Bean也交给spring来管理 2、使用aop:config标签表明开始AOP的配置 3、使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 4、在aop:aspect标签的内部使用对应标签来配置通知的类型 我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) --&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* cn.wang.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\" &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 通知类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"动态代理","slug":"动态代理","date":"2019-08-14T15:11:46.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/14/动态代理/","link":"","permalink":"https://summercat7.github.io/2019/08/14/动态代理/","excerpt":"","text":"为什么要用代理* 最主要的原因就是，在不改变目标对象方法的情况下对方法进行增强。 * 比如，我们希望对方法的调用增加日志记录，或者对方法的调用进行拦截，等等...基于接口的动态代理接口1234567891011121314public interface IProducer &#123; /** * 销售 * @param money */ public void saleProduct(float money); /** * 售后 * @param money */ public void afterService(float money);&#125; 实现类123456789101112131415161718public class Producer implements IProducer&#123; /** * 销售 * @param money */ public void saleProduct(float money)&#123; System.out.println(\"销售产品，并拿到钱：\"+money); &#125; /** * 售后 * @param money */ public void afterService(float money)&#123; System.out.println(\"提供售后服务，并拿到钱：\"+money); &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Client &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); /** * 动态代理： * 特点：字节码随用随创建，随用随加载 * 作用：不修改源码的基础上对方法增强 * 分类： * 基于接口的动态代理 * 基于子类的动态代理 * 基于接口的动态代理： * 涉及的类：Proxy * 提供者：JDK官方 * 如何创建代理对象： * 使用Proxy类中的newProxyInstance方法 * 创建代理对象的要求： * 被代理类最少实现一个接口，如果没有则不能使用 * newProxyInstance方法的参数： * ClassLoader：类加载器 * 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。 * Class[]：字节码数组 * 它是用于让代理对象和被代理对象有相同方法。固定写法。 * InvocationHandler：用于提供增强的代码 * 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。 * 此接口的实现类都是谁用谁写。 */ IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 作用：执行被代理对象的任何接口方法都会经过该方法 * 方法参数的含义 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需的参数 * @return 和被代理对象方法有相同的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //提供增强的代码 Object returnValue = null; //1.获取方法执行的参数 Float money = (Float)args[0]; //2.判断当前方法是不是销售 if(\"saleProduct\".equals(method.getName())) &#123; returnValue = method.invoke(producer, money*0.8f); &#125; return returnValue; &#125; &#125;); proxyProducer.saleProduct(10000f); &#125;&#125; 基于子类的动态代理被代理的非最终类123456789101112131415161718public class Producer &#123; /** * 销售 * @param money */ public void saleProduct(float money)&#123; System.out.println(\"销售产品，并拿到钱：\"+money); &#125; /** * 售后 * @param money */ public void afterService(float money)&#123; System.out.println(\"提供售后服务，并拿到钱：\"+money); &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Client &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); /** * 动态代理： * 特点：字节码随用随创建，随用随加载 * 作用：不修改源码的基础上对方法增强 * 分类： * 基于接口的动态代理 * 基于子类的动态代理 * 基于子类的动态代理： * 涉及的类：Enhancer * 提供者：第三方cglib库 * 如何创建代理对象： * 使用Enhancer类中的create方法 * 创建代理对象的要求： * 被代理类不能是最终类 * create方法的参数： * Class：字节码 * 它是用于指定被代理对象的字节码。 * * Callback：用于提供增强的代码 * 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。 * 此接口的实现类都是谁用谁写。 * 我们一般写的都是该接口的子接口实现类：MethodInterceptor */ Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; /** * 执行北地阿里对象的任何方法都会经过该方法 * @param proxy * @param method * @param args * 以上三个参数和基于接口的动态代理中invoke方法的参数是一样的 * @param methodProxy ：当前执行方法的代理对象 * @return * @throws Throwable */ @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //提供增强的代码 Object returnValue = null; //1.获取方法执行的参数 Float money = (Float)args[0]; //2.判断当前方法是不是销售 if(\"saleProduct\".equals(method.getName())) &#123; returnValue = method.invoke(producer, money*0.8f); &#125; return returnValue; &#125; &#125;); cglibProducer.saleProduct(12000f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门3","slug":"Spring入门3","date":"2019-08-14T09:22:13.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/14/Spring入门3/","link":"","permalink":"https://summercat7.github.io/2019/08/14/Spring入门3/","excerpt":"","text":"Spring(IOC)使用注解 配置类123456789101112131415161718192021222324252627282930313233343536/** * 该类是一个配置类，它的作用和bean.xml是一样的 * spring中的新注解 * Configuration * 作用：指定当前类是一个配置类 * 细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。 * ComponentScan * 作用：用于通过注解指定spring在创建容器时要扫描的包 * 属性： * value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。 * 我们使用此注解就等同于在xml中配置了: * &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; * Bean * 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中 * 属性: * name:用于指定bean的id。当不写时，默认值是当前方法的名称 * 细节： * 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。 * 查找的方式和Autowired注解的作用是一样的 * Import * 作用：用于导入其他的配置类 * 属性： * value：用于指定其他配置类的字节码。 * 当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类 * PropertySource * 作用：用于指定properties文件的位置 * 属性： * value：指定文件的名称和路径。 * 关键字：classpath，表示类路径下 *///@Configuration@ComponentScan(\"com.itheima\")@Import(JdbcConfig.class)@PropertySource(\"classpath:jdbcConfig.properties\")public class SpringConfiguration &#123;&#125; 子配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 和spring连接数据库相关的配置类 */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; /** * 用于创建一个QueryRunner对象 * @param dataSource * @return */ @Bean(name=\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(@Qualifier(\"ds2\") DataSource dataSource)&#123; return new QueryRunner(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name=\"ds2\") public DataSource createDataSource()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125; @Bean(name=\"ds1\") public DataSource createDataSource1()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/java\"); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125;&#125; 持久层123456789101112131415161718/** * 账户的持久层实现类 */@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private QueryRunner runner; @Override public List&lt;Account&gt; findAllAccount() &#123; try&#123; return runner.query(\"select * from account\",new BeanListHandler&lt;Account&gt;(Account.class)); &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 测试类(spring使用junit)1234567891011121314151617181920212223242526272829/** * 使用Junit单元测试：测试我们的配置 * Spring整合junit的配置 * 1、导入spring整合junit的jar(坐标) * 2、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的 * @Runwith * 3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置 * @ContextConfiguration * locations：指定xml文件的位置，加上classpath关键字，表示在类路径下 * classes：指定注解类所在地位置 * * 当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest &#123; @Autowired private IAccountService as = null; @Test public void testFindAll() &#123; //3.执行方法 List&lt;Account&gt; accounts = as.findAllAccount(); for(Account account : accounts)&#123; System.out.println(account); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门2","slug":"Spring入门2","date":"2019-08-12T14:18:29.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/12/Spring入门2/","link":"","permalink":"https://summercat7.github.io/2019/08/12/Spring入门2/","excerpt":"","text":"Spring(IOC)使用 注解+xml 配置文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为 context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; service1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 账户的业务层实现类 * * 曾经XML的配置： * &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" * scope=\"\" init-method=\"\" destroy-method=\"\"&gt; * &lt;property name=\"\" value=\"\" | ref=\"\"&gt;&lt;/property&gt; * &lt;/bean&gt; * * 用于创建对象的 * 他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 * Component: * 作用：用于把当前类对象存入spring容器中 * 属性： * value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 * Controller：一般用在表现层 * Service：一般用在业务层 * Repository：一般用在持久层 * 以上三个注解他们的作用和属性与Component是一模一样。 * 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 * * * 用于注入数据的 * 他们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的 * Autowired: * 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功 * 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 * 如果Ioc容器中有多个类型匹配时： * 出现位置： * 可以是变量上，也可以是方法上 * 细节： * 在使用注解注入时，set方法就不是必须的了。 * Qualifier: * 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以（稍后我们讲） * 属性： * value：用于指定注入bean的id。 * Resource * 作用：直接按照bean的id注入。它可以独立使用 * 属性： * name：用于指定bean的id。 * 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。 * 另外，集合类型的注入只能通过XML来实现。 * * Value * 作用：用于注入基本类型和String类型的数据 * 属性： * value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式） * SpEL的写法：$&#123;表达式&#125; * * 用于改变作用范围的 * 他们的作用就和在bean标签中使用scope属性实现的功能是一样的 * Scope * 作用：用于指定bean的作用范围 * 属性： * value：指定范围的取值。常用取值：singleton prototype * * 和生命周期相关 了解 * 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的 * PreDestroy * 作用：用于指定销毁方法 * PostConstruct * 作用：用于指定初始化方法 */@Service(\"accountService\")//@Scope(\"prototype\")public class AccountServiceImpl implements IAccountService &#123;// @Autowired// @Qualifier(\"accountDao1\") @Resource(name = \"accountDao2\") private IAccountDao accountDao = null; @PostConstruct public void init()&#123; System.out.println(\"初始化方法执行了\"); &#125; @PreDestroy public void destroy()&#123; System.out.println(\"销毁方法执行了\"); &#125; public void saveAccount()&#123; accountDao.saveAccount(); &#125;&#125; 测试类1234567891011121314151617181920public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\");// IAccountService as2 = (IAccountService)ac.getBean(\"accountService\");// System.out.println(as);// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// System.out.println(adao);// System.out.println(as == as2); as.saveAccount(); ac.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Spring入门1","slug":"Spring入门1","date":"2019-08-09T12:38:46.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/09/Spring入门1/","link":"","permalink":"https://summercat7.github.io/2019/08/09/Spring入门1/","excerpt":"","text":"Spring(IOC)使用xml方式 创建bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来管理--&gt; &lt;!--spring对bean的管理细节 1.创建bean的三种方式 2.bean对象的作用范围 3.bean对象的生命周期 --&gt; &lt;!--创建Bean的三种方式 --&gt; &lt;!-- 第一种方式：使用默认构造函数创建。 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。 采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。 &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; --&gt; &lt;!-- 第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器） &lt;bean id=\"instanceFactory\" class=\"com.itheima.factory.InstanceFactory\"&gt;&lt;/bean&gt; &lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; --&gt; &lt;!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器) &lt;bean id=\"accountService\" class=\"com.itheima.factory.StaticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean的作用范围调整 bean标签的scope属性： 作用：用于指定bean的作用范围 取值： 常用的就是单例的和多例的 singleton：单例的（默认值） prototype：多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" scope=\"prototype\"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean对象的生命周期 单例对象 出生：当容器创建时对象出生 活着：只要容器还在，对象一直活着 死亡：容器销毁，对象消亡 总结：单例对象的生命周期和容器相同 多例对象 出生：当我们使用对象时spring框架为我们创建 活着：对象只要是在使用过程中就一直活着。 死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" scope=\"prototype\" init-method=\"init\" destroy-method=\"destroy\"&gt;&lt;/bean&gt;&lt;/beans&gt; 依赖注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- spring中的依赖注入 依赖注入： Dependency Injection IOC的作用： 降低程序间的耦合（依赖关系） 依赖关系的管理： 以后都交给spring来维护 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 依赖关系的维护： 就称之为依赖注入。 依赖注入： 能注入的数据：有三类 基本类型和String 其他bean类型（在配置文件中或者注解配置过的bean） 复杂类型/集合类型 注入的方式：有三种 第一种：使用构造函数提供 第二种：使用set方法提供 第三种：使用注解提供（明天的内容） --&gt; &lt;!--构造函数注入： 使用的标签:constructor-arg 标签出现的位置：bean标签的内部 标签中的属性 type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值 常用的 =============以上三个用于指定给构造函数中哪个参数赋值=============================== value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 弊端： 改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"泰斯特\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 配置一个日期对象 --&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; &lt;!-- set方法注入 更常用的方式 涉及的标签：property 出现的位置：bean标签的内部 标签的属性 name：用于指定注入时所调用的set方法名称 value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 创建对象时没有明确的限制，可以直接使用默认构造函数 弊端： 如果有某个成员必须有值，则获取对象是有可能set方法没有执行。 --&gt; &lt;bean id=\"accountService2\" class=\"com.itheima.service.impl.AccountServiceImpl2\"&gt; &lt;property name=\"name\" value=\"TEST\" &gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 复杂类型的注入/集合类型的注入 用于给List结构集合注入的标签： list array set 用于个Map结构集合注入的标签: map props 结构相同，标签可以互换 --&gt; &lt;bean id=\"accountService3\" class=\"com.itheima.service.impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testC\"&gt;ccc&lt;/prop&gt; &lt;prop key=\"testD\"&gt;ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"testA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;entry key=\"testB\"&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码12345678910111213public class Client &#123; public static void main(String[] args) &#123; //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); as.saveAccount(); //手动关闭容器 ac.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"mybatis入门2","slug":"mybatis入门2","date":"2019-08-06T14:39:05.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/06/mybatis入门2/","link":"","permalink":"https://summercat7.github.io/2019/08/06/mybatis入门2/","excerpt":"","text":"mybatis 注解方式 mybatis 注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(&quot;insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)&quot;) void saveUser(User user); /** * 更新用户 * @param user */ @Update(&quot;update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;) void updateUser(User user); /** * 删除用户 * @param userId */ @Delete(&quot;delete from user where id=#&#123;id&#125; &quot;) void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */// @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) @Select(&quot;select * from user where username like &apos;%$&#123;value&#125;%&apos; &quot;) List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * @return */ @Select(&quot;select count(*) from user &quot;) int findTotalUser();&#125; 一对多注解IUserDao1234567891011121314151617181920212223242526272829303132333435363738@CacheNamespace(blocking = true)public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(\"select * from user\") @Results(id=\"userMap\",value=&#123; @Result(id=true,column = \"id\",property = \"userId\"), @Result(column = \"username\",property = \"userName\"), @Result(column = \"address\",property = \"userAddress\"), @Result(column = \"sex\",property = \"userSex\"), @Result(column = \"birthday\",property = \"userBirthday\"), @Result(property = \"accounts\",column = \"id\", many = @Many(select = \"com.itheima.dao.IAccountDao.findAccountByUid\", fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") @ResultMap(\"userMap\") User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125; \") @ResultMap(\"userMap\") List&lt;User&gt; findUserByName(String username);&#125; IAccountDao1234567891011121314151617181920212223public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * @return */ @Select(\"select * from account\") @Results(id=\"accountMap\",value = &#123; @Result(id=true,column = \"id\",property = \"id\"), @Result(column = \"uid\",property = \"uid\"), @Result(column = \"money\",property = \"money\"), @Result(property = \"user\",column = \"uid\",one=@One(select=\"com.itheima.dao.IUserDao.findById\",fetchType= FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll(); /** * 根据用户id查询账户信息 * @param userId * @return */ @Select(\"select * from account where uid = #&#123;userId&#125;\") List&lt;Account&gt; findAccountByUid(Integer userId);&#125; 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init()throws Exception&#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy()throws Exception&#123; session.commit(); session.close(); in.close(); &#125; @Test public void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll();// for(User user : users)&#123;// System.out.println(\"---每个用户的信息----\");// System.out.println(user);// System.out.println(user.getAccounts());// &#125; &#125; @Test public void testFindOne()&#123; User user = userDao.findById(57); System.out.println(user); &#125; @Test public void testFindByName()&#123; List&lt;User&gt; users = userDao.findUserByName(\"%mybatis%\"); for(User user : users)&#123; System.out.println(user); &#125; &#125;&#125; mybatis 缓存* 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis 中缓存分为一级缓存，二级缓存。 * 一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 * 一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等 * 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句， 多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。测试类1234567891011121314151617181920212223242526272829303132public class SecondLevelCatchTest &#123; private InputStream in; private SqlSessionFactory factory; @Before public void init()throws Exception&#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); &#125; @After public void destroy()throws Exception&#123; in.close(); &#125; @Test public void testFindOne()&#123; SqlSession session = factory.openSession(); IUserDao userDao = session.getMapper(IUserDao.class); User user = userDao.findById(57); System.out.println(user); session.close();//释放一级缓存 SqlSession session1 = factory.openSession();//再次打开session IUserDao userDao1 = session1.getMapper(IUserDao.class); User user1 = userDao1.findById(57); System.out.println(user1); session1.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"mybatis入门1","slug":"mybatis入门1","date":"2019-08-06T13:55:42.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/08/06/mybatis入门1/","link":"","permalink":"https://summercat7.github.io/2019/08/06/mybatis入门1/","excerpt":"","text":"mybatis框架概述:是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来 学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。SqlMapConfig.xml 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"jdbcConfig.properties\"&gt;&lt;/properties&gt; &lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis支持延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt; &lt;/settings&gt; &lt;!--使用typeAliases配置别名，它只能配置domain中类的别名 --&gt; &lt;typeAliases&gt; &lt;!--typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就再区分大小写 &lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt; &lt;package name=\"cn.wang.domain\"&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!--配置文件 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射文件路径--&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"cn/wang/dao/UserDao.xml\"&gt;&lt;/mapper&gt;--&gt; &lt;!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 --&gt; &lt;package name=\"cn.wang.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层接口的映射文件 UserDao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.wang.dao.UserDao\"&gt; &lt;sql id=\"default\"&gt; select *from user &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"cn.wang.domain.User\"&gt; &lt;include refid=\"default\"&gt;&lt;/include&gt; &lt;/select&gt; &lt;insert id=\"saveUser\" parameterType=\"cn.wang.domain.User\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,address,sex,birthday) value(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"cn.wang.domain.User\"&gt; update user set address=#&#123;address&#125; where username=#&#123;username&#125;; &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;uid&#125;; &lt;/delete&gt; &lt;select id=\"findOne\" parameterType=\"java.lang.Integer\" resultType=\"cn.wang.domain.User\"&gt; select * from user where id=#&#123;uid&#125;; &lt;/select&gt; &lt;select id=\"findByCondition\" resultType=\"cn.wang.domain.User\" parameterType=\"cn.wang.domain.User\"&gt; &lt;!--select * from user where 1=1 &lt;if test=\"username != null\"&gt; and username = #&#123;username&#125; &lt;/if&gt;--&gt; select * from user &lt;where&gt; &lt;if test=\"username != null\"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=\"findUserInIds\" resultType=\"cn.wang.domain.User\" parameterType=\"cn.wang.domain.QueryVo\"&gt; &lt;include refid=\"default\"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=\"ids !=null and ids.size()&gt;0\"&gt; &lt;foreach collection=\"ids\" open=\"and id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 一对多 xml配置1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"INT\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 多对多 xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property=\"roles\" ofType=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"INT\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 编写测试类123456789101112131415161718192021222324252627282930313233343536public class UserTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(true); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; //提交事务 // sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(\"-----每个用户的信息------\"); System.out.println(user); System.out.println(user.getRoles()); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://summercat7.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"redis","slug":"redis","date":"2019-07-26T13:11:48.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/26/redis/","link":"","permalink":"https://summercat7.github.io/2019/07/26/redis/","excerpt":"","text":"Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 * 访问jedis1234567891011121314151617181920212223242526272829public class ProvinceServiceImpl implements ProvinceService &#123; private ProvinceDao dao = new ProvinceDaoImpl(); @Override public List&lt;Province&gt; findAll() &#123; return dao.findAll(); &#125; @Override public String findAllJson() &#123; Jedis jedis = JedisPoolUtils.getJedis(); String province_json = jedis.get(\"province\"); if (province_json == null || province_json.length() == 0) &#123; System.out.println(\"redis中没有数据，访问数据库\"); List&lt;Province&gt; list = dao.findAll(); ObjectMapper mapper = new ObjectMapper(); try &#123; province_json = mapper.writeValueAsString(list); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; jedis.set(\"province\",province_json); jedis.close(); &#125; else &#123; System.out.println(\"redis中有数据，访问缓存\"); &#125; return province_json; &#125;&#125;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://summercat7.github.io/categories/SQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://summercat7.github.io/tags/redis/"}],"keywords":[{"name":"SQL","slug":"SQL","permalink":"https://summercat7.github.io/categories/SQL/"}]},{"title":"JQuery","slug":"JQuery","date":"2019-07-25T12:47:52.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/25/JQuery/","link":"","permalink":"https://summercat7.github.io/2019/07/25/JQuery/","excerpt":"","text":"JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点JQuery 高级1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summercat7.github.io/categories/JavaScript/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://summercat7.github.io/tags/JQuery/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://summercat7.github.io/categories/JavaScript/"}]},{"title":"过滤器使用与bean注入","slug":"过滤器使用与bean注入","date":"2019-07-24T13:23:34.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/24/过滤器使用与bean注入/","link":"","permalink":"https://summercat7.github.io/2019/07/24/过滤器使用与bean注入/","excerpt":"","text":"1 web.xml中各元素启动顺序在项目启动时，监听器listener最先初始化，然后是过滤器filter，最后是servlet。Spring监听器在启动时会读取spring配置文件，进行spring容器的初始化。springMVC的dispatcherServlet初始化时会读取springMVC的配置文件，进行springMVC容器的初始化。Spring容器初始化时会实例化各个bean。（个人认为web容器初始化时其中的各元素是按上述顺序依次初始化的，其他元素全部初始化完成之后web容器才初始化完成。但目前没有看到过一个十分确切的说法，等以后有时间研究一下源码）。 2 过滤器的使用网上很多资料说在过滤器中拿不到spring注入的bean，原因是过滤器初始化时spring容器还没初始化好，其实并不是。下面看一段代码：在web.xml中定义过滤器： 12345678&lt;filter&gt; &lt;filter-name&gt;demoFilter&lt;/filter-name&gt; &lt;filter-class&gt;xx.framework.filter.demoFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demoFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在过滤器的初始化方法init中： 123456@Overridepublic void init(FilterConfig filterConfig) throws ServletException &#123; ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(filterConfig.getServletContext()); RedisTemplate demoBean = (RedisTemplate)context.getBean(&quot;redisTemplate&quot;); System.out.println(demoBean); &#125; 经过测试，此时是可以拿到spring中的redisTemplate 这个bean的，说明spring容器确实先于过滤器初始化的。那么回到过滤器中不能注入bean的问题，原因究竟是什么呢？可以看到，这里获取bean是通过applicationContext获取的，而不是直接注入的。个人理解是：过滤器是servlet规范中定义的，并不归spring容器管理，也无法直接注入spring中的bean（会报错）。当然，要想通过spring注入的方式来使用过滤器也是有办法的,先在web.xml中定义： 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;DelegatingFilterProxy&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetBeanName&lt;/param-name&gt; &lt;param-value&gt;demoFilter&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;DelegatingFilterProxy&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在spring容器中配置demoFilter这个bean： 1&lt;bean id=&quot;demoFilter&quot; class=&quot;xx.framework.filter.demoFilter&quot; /&gt; 在doFilter方法中可以获取到注入的bean了： 1234@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(redisTemplate.getClientList());&#125; 其中redisTemplate是通过@Resource注解注入进来的。","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Filter&Listener笔记","slug":"Filter-Listener笔记","date":"2019-07-24T13:22:34.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/24/Filter-Listener笔记/","link":"","permalink":"https://summercat7.github.io/2019/07/24/Filter-Listener笔记/","excerpt":"","text":"Filter：过滤器1. 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门： 1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 123456789101112131415161718192021public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"filterDemo1被执行了....\"); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 3. 过滤器细节： 1. web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 4. 案例： 1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。 123456789101112131415 public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; String uri = request.getRequestURI(); if (uri.contains(\"/login.jsp\") || uri.contains(\"loginServlet\") || uri.contains(\"/js/\") || uri.contains(\"/css/\") || uri.contains(\"/fonts/\") || uri.contains(\"/checkCodeServlet\")) &#123; chain.doFilter(req, resp); &#125; else &#123; Object user = request.getSession().getAttribute(\"user\"); if (user != null) &#123; chain.doFilter(req, resp); &#125; else &#123; request.setAttribute(\"login_msg\",\"请登录后操作\"); request.getRequestDispatcher(\"/login.jsp\").forward(request,resp); &#125; &#125;&#125; 2. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 * 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 12345678910111213141516171819202122232425262728293031323334353637383940public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName() == \"getParameter\") &#123; String value = (String) method.invoke(req,args); if (value != null) &#123; for (String str : list) &#123; if (value.contains(str)) &#123; value = value.replaceAll(str, \"***\"); &#125; &#125; &#125; System.out.println(\"return:\"+value); return value; &#125; return method.invoke(req,args); &#125; &#125;); chain.doFilter(proxy_req, resp);&#125;private List&lt;String&gt; list = new ArrayList&lt;&gt;();public void init(FilterConfig config) throws ServletException &#123; try &#123; ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath(\"/WEB-INF/classes/敏感词汇.txt\"); File file = new File(realPath); System.out.println(file.exists()); System.out.println(realPath); BufferedReader br = new BufferedReader(new FileReader(realPath)); String line = null; while ((line = br.readLine())!=null) &#123; list.add(line); &#125; System.out.println(list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;Listener：监听器* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"Response笔记","slug":"Response笔记","date":"2019-07-22T07:58:11.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/22/Response笔记/","link":"","permalink":"https://summercat7.github.io/2019/07/22/Response笔记/","excerpt":"","text":"HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt;Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader(\"pragma\",\"no-cache\"); response.setHeader(\"cache-control\",\"no-cache\"); response.setHeader(\"expires\",\"0\"); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute(\"CHECKCODE_SERVER\",checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font(\"黑体\",Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,\"PNG\",response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = \"0123456789ABCDEFGabcdefg\"; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125;ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a);案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[],"tags":[],"keywords":[]},{"title":"Servlet&HTTP&Request笔记","slug":"Servlet-HTTP-Request笔记","date":"2019-07-22T07:48:14.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/22/Servlet-HTTP-Request笔记/","link":"","permalink":"https://summercat7.github.io/2019/07/22/Servlet-HTTP-Request笔记/","excerpt":"","text":"Servlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext()12345String url = request.getScheme()+\"://\"+ request.getServerName()+request.getRequestURI()+\"?\"+request.getQueryString();System.out.println(\"获取全路径（协议类型：//域名/项目名/命名空间/action名称?其他参数）url=\"+url);String url2=request.getScheme()+\"://\"+ request.getServerName();//+request.getRequestURI();System.out.println(\"协议名：//域名=\"+url2); 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-07-17T05:14:07.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/17/JDBC/","link":"","permalink":"https://summercat7.github.io/2019/07/17/JDBC/","excerpt":"","text":"数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } }Spring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"MySQL基础语法","slug":"MySQL基础语法","date":"2019-07-15T11:08:26.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/15/MySQL基础语法/","link":"","permalink":"https://summercat7.github.io/2019/07/15/MySQL基础语法/","excerpt":"","text":"DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ;数据库的备份和还原* 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径基础语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970CREATE TABLE student ( id INT, -- 编号 NAME VARCHAR(20), -- 姓名 age INT, -- 年龄 sex VARCHAR(5), -- 性别 address VARCHAR(100), -- 地址 math INT, -- 数学 english INT -- 英语);INSERT INTO student(id,NAME,age,sex,address,math,english) VALUES (1,'马云',55,'男','杭州',66,78),(2,'马化腾',45,'女','深圳',98,87),(3,'马景涛',55,'男','香港',56,77),(4,'柳岩',20,'女','湖南',76,65),(5,'柳青',20,'男','湖南',86,NULL),(6,'刘德华',57,'男','香港',99,99),(7,'马德',22,'女','香港',99,99),(8,'德玛西亚',18,'男','南京',56,65);UPDATE student SET id = 003 WHERE id = 1;DELETE FROM student WHERE id=1;DROP TABLE student;TRUNCATE TABLE student;-- 查询姓名和年龄SELECT NAME,age FROM student;-- 去除重复的结果集SELECT DISTINCT address FROM student;-- 计算 math 和 English 的和SELECT NAME,math,english,math+english FROM student;-- 如果有null 参与运算，结果都为nullSELECT NAME,math,english,math+IFNULL(english,0) FROM student;-- 起别名SELECT NAME,math,english,math+IFNULL(english,0) AS 总分 FROM student;SELECT NAME,math 数学,english 英语,math+IFNULL(english,0) 总分 FROM student;-- 查询年龄大于20SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄大于20SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄再20和30之间SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;= 30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄为18,22,25SELECT * FROM student WHERE age = 18 OR age = 22 OR age = 25;SELECT * FROM student WHERE age IN (18,22,25);-- 查询是否为null， 不能使用=(!=)SELECT * FROM student WHERE english IS NULL;SELECT * FROM student WHERE english IS NOT NULL;-- 查询姓名第二个字是“化”SELECT * FROM student WHERE NAME LIKE \"_化%\";-- 查询姓名是三个字的SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名含有“德”的SELECT * FROM student WHERE NAME LIKE \"%德%\";-- 排序SELECT * FROM student ORDER BY math DESC , english ASC;-- 聚合函数（纵向计算）SELECT COUNT(IFNULL(english,0)) FROM student;SELECT MAX(english) FROM student;SELECT MIN(english) FROM student;SELECT SUM(english) FROM student;SELECT AVG(english) FROM student;-- 分组查询SELECT sex,AVG(english),COUNT(id) FROM student GROUP BY sex;SELECT sex,AVG(english),COUNT(id) FROM student WHERE english &gt; 70 GROUP BY sex;SELECT sex,AVG(english),COUNT(id) FROM student WHERE english &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;-- 分页SELECT * FROM student LIMIT 3,3; 约束条件1234567891011121314151617181920212223242526272829303132CREATE TABLE obj( id INT PRIMARY KEY, NAME VARCHAR(10) DEFAULT \"数学\");CREATE TABLE st( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL, number VARCHAR(20), uid INT, CONSTRAINT uk FOREIGN KEY (uid) REFERENCES obj(id));-- 删除非空ALTER TABLE st MODIFY NAME VARCHAR(10);ALTER TABLE st MODIFY NAME VARCHAR(20) NOT NULL;-- 唯一约束ALTER TABLE st MODIFY number INT UNIQUE;-- 删除唯一约束ALTER TABLE st DROP INDEX number ; -- 删除主键ALTER TABLE st DROP PRIMARY KEY;-- 添加主键ALTER TABLE st MODIFY id INT PRIMARY KEY;-- 添加自动增长ALTER TABLE st MODIFY id INT AUTO_INCREMENT;-- 删除自动增长ALTER TABLE st MODIFY id INT;-- 删除外键ALTER TABLE st DROP FOREIGN KEY uk;-- 添加外键,设置级联更新ALTER TABLE st ADD CONSTRAINT uk FOREIGN KEY (uid) REFERENCES obj(id) ON UPDATE CASCADE; -- ON DELETE CASCADE 多表查询： 多表查询的分类： 内连接查询： 隐式内连接：使用where条件消除无用数据 例子：SELECT t1.name, – 员工表的姓名 t1.gender,– 员工表的性别 t2.name – 部门表的名称FROM emp t1, dept t2WHERE t1.dept_id = t2.id; 2. 显式内连接： * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询： 1. 从哪些表中查询数据 2. 条件是什么 3. 查询哪些字段 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 3. 子查询： * 概念：查询中嵌套查询，称嵌套查询为子查询。 -- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = * -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos;事务1. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子： CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0; 2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2;DCL：* SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 * DBA：数据库管理员 * DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; 2. 删除用户： * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;; UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;; SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;; REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://summercat7.github.io/categories/SQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://summercat7.github.io/tags/MySQL/"}],"keywords":[{"name":"SQL","slug":"SQL","permalink":"https://summercat7.github.io/categories/SQL/"}]},{"title":"lock锁","slug":"lock锁","date":"2019-07-11T15:05:05.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/11/lock锁/","link":"","permalink":"https://summercat7.github.io/2019/07/11/lock锁/","excerpt":"","text":"###lock锁基础 12345678910111213141516171819202122232425262728293031323334353637383940package cn.wang.d07_thread.t02_safe;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class pay implements Runnable&#123; private int piao = 100; //创建锁对象 Lock l = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; //调用锁方法 l.lock(); if (piao &gt; 0) &#123; try &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \"--&gt;\" + piao--); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //在finally解锁，可以使无论是否异常都解锁 l.unlock(); &#125; &#125; &#125; &#125;&#125;public class lock_test &#123; public static void main(String[] args) &#123; pay piao = new pay(); Thread t1 = new Thread(piao); Thread t2 = new Thread(piao); Thread t3 = new Thread(piao); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"同步代码块和同步方法","slug":"同步代码块和同步方法","date":"2019-07-11T15:03:46.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/07/11/同步代码块和同步方法/","link":"","permalink":"https://summercat7.github.io/2019/07/11/同步代码块和同步方法/","excerpt":"","text":"##java线程基础 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Piao implements Runnable&#123; private static int piao = 100; Object obj = new Object(); //静态方法用的是本类class的属性--&gt;class文件对象（反射） private static /*synchronized*/ void staticfunc()&#123; synchronized (Runnable.class)&#123; if(piao&gt;0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + piao--); &#125; &#125; &#125; @Override public void run() &#123; while(true)&#123;// func(); staticfunc();// synchronized (obj)&#123;// if(piao&gt;0)&#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()+\"--&gt;\"+piao--);// &#125;else &#123;// break;// &#125;// &#125; &#125; &#125; private /*synchronized*/ void func()&#123; synchronized (this)&#123; if(piao&gt;0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+piao--); &#125; &#125; &#125;&#125;public class synchronized_test &#123; public static void main(String[] args) &#123; Piao piao = new Piao(); Thread t1 = new Thread(piao); Thread t2 = new Thread(piao); Thread t3 = new Thread(piao); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://summercat7.github.io/categories/java/"}]},{"title":"线段树","slug":"线段树","date":"2019-06-27T04:04:32.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/06/27/线段树/","link":"","permalink":"https://summercat7.github.io/2019/06/27/线段树/","excerpt":"","text":"##线段树基础使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;struct shu&#123; int l; int r; int n;&#125;p[150050];void init(int l,int r,int rt)&#123; if(l==r) &#123; p[rt].l=l; p[rt].r=r; p[rt].n=0; return ; &#125; int mid=(l+r)&gt;&gt;1; p[rt].l=l; p[rt].r=r; p[rt].n=0; init(l,mid,rt&lt;&lt;1); init(mid+1,r,rt&lt;&lt;1|1);&#125;void f(int n,int s,int k)&#123; if(p[k].l==p[k].r&amp;&amp;p[k].l==n) &#123; p[k].n+=s; return ; &#125; int mid=(p[k].l+p[k].r)&gt;&gt;1; if(n&lt;=mid) f(n,s,k&lt;&lt;1); else f(n,s,k&lt;&lt;1|1); p[k].n=p[k&lt;&lt;1].n+p[k&lt;&lt;1|1].n;&#125;int s;void ff(int l,int r,int k)&#123; if(p[k].l==l&amp;&amp;p[k].r==r) &#123; s+=p[k].n; return ; &#125; int mid=(p[k].l+p[k].r)&gt;&gt;1; if(r&lt;=mid) ff(l,r,k&lt;&lt;1); else if(l&gt;mid) ff(l,r,k&lt;&lt;1|1); else &#123; ff(l,mid,k&lt;&lt;1); ff(mid+1,r,k&lt;&lt;1|1); &#125;&#125;int main()&#123; int T,n,a,i,b,c; char w[10]; while(~scanf(\"%d\",&amp;T)) &#123; c=1; while(T--) &#123; s=0; scanf(\"%d\",&amp;n); init(1,n,1); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a); f(i,a,1); &#125; printf(\"Case %d:\\n\",c++); while(1) &#123; scanf(\"%s\",w); if(w[0]=='E') break; scanf(\"%d%d\",&amp;a,&amp;b); if(w[0]=='A') f(a,b,1); if(w[0]=='S') f(a,-b,1); if(w[0]=='Q') &#123; s=0; ff(a,b,1); printf(\"%d\\n\",s); &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}]},{"title":"wordcloud","slug":"wordcloud","date":"2019-06-24T00:36:08.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/06/24/wordcloud/","link":"","permalink":"https://summercat7.github.io/2019/06/24/wordcloud/","excerpt":"","text":"##wordcloud常用操作 123456789101112131415161718192021222324252627282930313233from wordcloud import WordCloud, ImageColorGeneratorimport jiebaimport imageiofrom matplotlib import pyplot as pltimg = imageio.imread('1.png')imgcolor = ImageColorGenerator(img)w = WordCloud(width=500, height=500, background_color=\"white\", font_path=\"msyh.ttc\", mask=img, scale=15, stopwords=&#123;'不想展示的词'&#125;, contour_width=1, contour_color='blue')text = \"计算机科学与技术\"text = jieba.lcut(text)text = \" \".join(text)w.generate(text)fig, axes = plt.subplots(1,3)axes[0].imshow(w)axes[1].imshow(w.recolor(color_func=imgcolor),interpolation=\"bilinear\")axes[2].imshow(img,cmap=plt.cm.gray)for ax in axes: ax.set_axis_off()plt.show()w1 = w.recolor(color_func=imgcolor)w.to_file(\"2.png\")","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"selenium","slug":"selenium","date":"2019-06-10T13:33:38.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/06/10/selenium/","link":"","permalink":"https://summercat7.github.io/2019/06/10/selenium/","excerpt":"","text":"###selenium基础使用 123456789101112131415161718192021222324252627282930313233343536from selenium import webdriverfrom selenium.webdriver.support.select import Selectimport timedriver = webdriver.Chrome(executable_path=\"E:\\\\Code\\\\python\\\\scrapy\\\\chromedriver.exe\")driver.fullscreen_window() # 最大化'''driver.get(\"http://www.baidu.com\")driver.find_element_by_id(\"kw\").send_keys(\"python\") # 输入值driver.find_element_by_id(\"su\").click() # 点击# driver.minimize_window()# driver.maximize_window()title = driver.title # 标题print(title)url = driver.current_url # 网址print(url)driver.back() # 上一页page = driver.page_source # 网页源代码print(page)driver.forward() # 下一页driver.close() # 关闭当前标签页# driver.quit()#关闭浏览器''''''#选择器driver.get(\"https://wannianrili.51240.com/\")year = driver.find_element_by_id(\"wnrl_xuanze_nian\")year = Select(year)year.select_by_visible_text(\"1997\")'''#截图driver.get(\"https://www.baidu.com\")driver.save_screenshot(r\"C:\\Users\\Administrator\\Desktop\\截图.png\")driver.close()","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"Centos下安装maven","slug":"mven","date":"2019-06-01T04:04:32.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/06/01/mven/","link":"","permalink":"https://summercat7.github.io/2019/06/01/mven/","excerpt":"","text":"Centos下安装maven1、maven下载地址：https://maven.apache.org/download.cgi 下载 apache-maven-3.6.1-bin.tar.gz 2、在linux环境中创建maven目录，/opt/myjava/maven，将maven安装包上传至此目录中解压 1tar -zxvf apache-maven-3.6.1-bin.tar.gz 3、配置环境变量 1vim /etc/profile 将下面这两行代码拷贝到文件末尾并保存 12export MAVEN_HOME=/opt/myjava/maven/apache-maven-3.6.1export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125; 重载环境变量 1source /etc/profile 4、查看结果 1mvn -v 5、替换maven源，阿里云的源 打开maven配置文件，比如： 1vim /opt/myjava/maven/apache-maven-3.6.1/conf/settings.xml 找到标签对，添加一下代码： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 6、指定下载资源位置 1&lt;localRepository&gt;/opt/myjava/maven_repository&lt;/localRepository&gt; 7、指定JDK版本 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"spider_header","slug":"spider_header","date":"2019-05-15T00:04:37.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/05/15/spider_header/","link":"","permalink":"https://summercat7.github.io/2019/05/15/spider_header/","excerpt":"","text":"###请求头设置 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport timefrom lxml import etreebase_url = 'http://yuanjian.cnki.net/Search/ListResult'headers=&#123; 'Host':'yuanjian.cnki.net', 'Referer':'http://yuanjian.cnki.net/Search/ListResult', 'User_Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36'&#125;Listkey=[]Listhref=[]param = &#123; 'searchType': 'MulityTermsSearch', 'Order': 2, 'KeyWord' : \"\", 'Page': 1&#125;def post_page(key): param[\"KeyWord\"]=key index=1 while True: param[\"Page\"]=index request=requests.post(base_url,data=param,headers=headers) html = etree.HTML(request.text) href = html.xpath('//p[@class=\"tit clearfix\"]/a[@class=\"left\"]/@href') for i in href: if i not in Listhref: Listhref.append(i) else: return None index=index+1 time.sleep(5)if __name__ == \"__main__\": str=post_page(\"MXD6\") print(len(Listhref)) html = Listhref[0] html = requests.get(Listhref[0]).text print(html)","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"树状数组","slug":"树状数组","date":"2019-04-22T10:12:54.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/04/22/树状数组/","link":"","permalink":"https://summercat7.github.io/2019/04/22/树状数组/","excerpt":"","text":"##树状树组基础使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100009;const ll md=998244353;int n,m;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0' || '9'&lt;ch)ch=getchar(); while('0'&lt;=ch &amp;&amp; ch&lt;='9')x=x*10+(ch^48),ch=getchar(); return x;&#125;inline ll qpow(ll a,ll b=md-2)&#123; ll ret=1; while(b) &#123; if(b&amp;1) ret=ret*a%md; a=a*a%md; b&gt;&gt;=1; &#125; return ret;&#125;inline ll merge(ll p1,ll p2)&#123; return (p1*p2%md+(1+md-p2)*(1+md-p1)%md)%md;&#125;namespace sseg&#123; int ch[N&lt;&lt;8][2],rt[N&lt;&lt;2],tot=1; ll val[N&lt;&lt;8]; inline void add(int &amp;x,int l,int r,int dl,int dr,ll v) &#123; if(!x)x=++tot,val[x]=1; if(dl==l &amp;&amp; r==dr)&#123;val[x]=merge(val[x],v);return;&#125; int mid=l+r&gt;&gt;1; if(dr&lt;=mid) add(ch[x][0],l,mid,dl,dr,v); else if(mid&lt;dl) add(ch[x][1],mid+1,r,dl,dr,v); else &#123; add(ch[x][0],l,mid,dl,mid,v); add(ch[x][1],mid+1,r,mid+1,dr,v); &#125; &#125; inline ll qsum(int x,int l,int r,int p) &#123; if(!x)return 1; if(l==r)return val[x]; int mid=l+r&gt;&gt;1; if(p&lt;=mid)return merge(val[x],qsum(ch[x][0],l,mid,p)); else return merge(val[x],qsum(ch[x][1],mid+1,r,p)); &#125; inline void modify(int x,int l,int r,int dl,int dr,int nl,int nr,ll v) &#123; if(dl==l &amp;&amp; r==dr)&#123;add(rt[x],1,n,nl,nr,v);return;&#125; int mid=l+r&gt;&gt;1; if(dr&lt;=mid) modify(x&lt;&lt;1,l,mid,dl,dr,nl,nr,v); else if(mid&lt;dl) modify(x&lt;&lt;1|1,mid+1,r,dl,dr,nl,nr,v); else &#123; modify(x&lt;&lt;1,l,mid,dl,mid,nl,nr,v); modify(x&lt;&lt;1|1,mid+1,r,mid+1,dr,nl,nr,v); &#125; &#125; inline ll query(int x,int l,int r,int px,int py) &#123; if(l==r)return qsum(rt[x],1,n,py);int mid=l+r&gt;&gt;1; if(px&lt;=mid)return merge(qsum(rt[x],1,n,py),query(x&lt;&lt;1,l,mid,px,py)); else return merge(qsum(rt[x],1,n,py),query(x&lt;&lt;1|1,mid+1,r,px,py)); &#125;&#125;int main()&#123; int root=1; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; if(read()==1) &#123; int l=read(),r=read();ll inv=qpow(r-l+1); if(l-1) &#123; sseg::modify(root,0,n,1,l-1,l,r,(1+md-inv)%md); sseg::modify(root,0,n,0,0,1,l-1,0); &#125; if(r&lt;n) &#123; sseg::modify(root,0,n,l,r,r+1,n,(1+md-inv)%md); sseg::modify(root,0,n,0,0,r+1,n,0); &#125; sseg::modify(root,0,n,l,r,l,r,(1+md-2*inv%md)%md); sseg::modify(root,0,n,0,0,l,r,inv); &#125; else &#123; int l=read(),r=read(); printf(\"%lld\\n\",sseg::query(1,0,n,l-1,r)); &#125; &#125; return 0;&#125; 参考","categories":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}]},{"title":"其他","slug":"其他","date":"2019-04-21T07:39:38.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/04/21/其他/","link":"","permalink":"https://summercat7.github.io/2019/04/21/其他/","excerpt":"","text":"windows开机自启动： winsw 内网穿透： frp , ngrok 域名： https://www.freenom.com/zh/index.html?lang=zh 算法图解： https://www.redblobgames.com/ 判断对象非空或设置默认值： Optional 函数式编程传递方法： Consumer","categories":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://summercat7.github.io/categories/其他/"}]},{"title":"spider","slug":"spider","date":"2019-04-21T07:18:16.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/04/21/spider/","link":"","permalink":"https://summercat7.github.io/2019/04/21/spider/","excerpt":"","text":"##获取拉链详情保持到本地excal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134from urllib.request import*from lxml import etreeimport reimport osimport timeimport xlwtfrom xlutils.copy import copyimport xlrddef imgdownload(imgurl,filename,name): #下载图片 try: print(\"下载。。。%s\"%name) imgurl = imgurl.replace(\" \",\"%20\") #将空白符替换成\"%20\" urlretrieve(imgurl, \".\\\\%s\\\\%s.jpg\" % (filename, name)) except Exception as e: print(\"=\"*70) print(\"下载异常详情：\") print(e) print(\"图片名：%s\\t图片地址：%s\"%(name,imgurl)) print(\"=\"*70)def excel(index,detailed_information): book1 = xlrd.open_workbook('ykk.xls') book2 = copy(book1) excel_sheet = book2.get_sheet(0) colIndex = 0 excel_headDatas = [\"商品名称\", \"商品类型\", \"商品链接\", \"商品简介\", \"商品用途\", \"注意事项\"] for item in excel_headDatas: excel_sheet.write(index, colIndex, detailed_information[item]) colIndex += 1 book2.save('ykk.xls')def new_excel(): excel_headDatas = [\"商品名称\", \"商品类型\", \"商品链接\", \"商品简介\", \"商品用途\", \"注意事项\"] excle_Workbook = xlwt.Workbook() excel_sheet = excle_Workbook.add_sheet(\"拉链\") index = 0 for data in excel_headDatas: excel_sheet.write(0, index, data) index += 1 excle_Workbook.save('ykk.xls')def look_details(details_urls): di = 1 line = 1 new_excel() gong = len(details_urls) for details_url in details_urls: name = details_url[\"name\"] stype = details_url[\"stype\"] url = details_url[\"url\"] try: print(\"=\"*100) print(\"第%d/%d个网页\"%(di,gong)) print(name) print(stype) print(url) html = urlopen(url).read().decode(\"utf-8\") html = etree.HTML(html) #简介 intro = '' intro_div = html.xpath('//div[@class=\"ProductInfo\"]') for string in intro_div[0].xpath('.//div[@class=\"text\"]/text()'): string = string.strip() intro += string print(intro) #用途 use = [] useul = html.xpath('//ul[@class=\"layoutItem col4 flexed\"]//text()') print(useul) for i in useul: i = i.replace(\"\\n\",'').strip() if i: use.append(i) use = '、'.join(use) print(use) #注意事项 announcements = '' andiv = html.xpath('//div[@class=\"area clearfix\"]')[0] andivs = etree.tostring(andiv, encoding=\"utf-8\").decode(\"utf-8\") subdiv = re.findall('&lt;h2&gt;注意事项((.|\\s)*?)&lt;/div&gt;', andivs) if len(subdiv)!=0: subdiv = subdiv[0][0] parser = etree.HTMLParser(encoding=\"utf-8\") subdiv = etree.HTML(subdiv, parser=parser) # subdiv = etree.tostring(subdiv,encoding=\"utf-8\").decode(\"utf-8\") text = subdiv.xpath('.//div//text()') announcements = ''.join(text) print(announcements) dic = &#123;\"商品名称\":name,\"商品类型\":stype,\"商品链接\":url,\"商品简介\":intro,\"商品用途\":use,\"注意事项\":announcements&#125; excel(line,dic) line += 1 except Exception as e: print(\"=\"*50) print(\"访问异常详情：\") print(e) print(\"异常网址：%s\"%url) print(\"=\"*50) finally: di += 1 print(\"=\"*100) time.sleep(10)def open_dict_url(urls): details_urls = [] for i in urls: filename = i[\"name\"] if not os.path.exists(\".\\\\%s\"%filename): os.mkdir(\".\\\\%s\"%filename) for index in range(1,3): url = i[\"url\"] + str(index) print(url) html = urlopen(url).read().decode(\"utf-8\") html = etree.HTML(html) result = html.xpath('//div[@class=\"ProductItems\"]') for div in result: imgurl = \"https://www.ykkfastening.com\" + div.xpath('.//img/@src')[0] url = \"https://www.ykkfastening.com\" + div.xpath('.//a/@href')[0] name = div.xpath('.//a/text()')[0].replace(' ','') name = re.sub('/|\\\\|\\||\\?|\\*|\"|&lt;|&gt;','_',name) #文件名不能出现符号 details_urls.append(&#123;\"name\":name,\"stype\":filename,\"url\":url&#125;) imgdownload(imgurl,filename,name) look_details(details_urls)if __name__ == \"__main__\": headers = (\"User-Agent\",\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\") opener = build_opener() opener.addheaders = [headers] install_opener(opener) urls = [&#123;\"name\": \"金属拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/metal_zipper/?pno_941=\"&#125;, &#123;\"name\": \"尼龙拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/coil_zipper/?pno_956=\"&#125;, &#123;\"name\": \"树脂拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/vislon_zipper/?pno_957=\"&#125;] open_dict_url(urls)","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2019-04-14T14:54:12.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/04/14/AC自动机/","link":"","permalink":"https://summercat7.github.io/2019/04/14/AC自动机/","excerpt":"","text":"##AC自动机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e6+9;int n;char ch[N];struct AC_automaton&#123; int ch[N][27],cnt[N],fail[N],pool; int ed[N],q[N],l,r; inline void insert(char *s,int id) &#123; int len=strlen(s+1),now=0; for(int i=1;i&lt;=len;i++) &#123; if(!ch[now][s[i]-'a']) ch[now][s[i]-'a']=++pool; now=ch[now][s[i]-'a']; cnt[now]++; &#125; ed[id]=now; &#125; inline void calc() &#123; fail[0]=0; q[r=1]=l=0; while(l&lt;r) &#123; int u=q[++l]; for(int i=0;i&lt;26;i++) if(ch[u][i]) &#123; q[++r]=ch[u][i]; fail[ch[u][i]]= u==0?0:ch[fail[u]][i]; &#125; else ch[u][i]= u==0?0:ch[fail[u]][i]; &#125; for(int i=r;i&gt;=1;i--) cnt[fail[q[i]]]+=cnt[q[i]]; for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",cnt[ed[i]]); &#125;&#125;koishi;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%s\",ch+1); koishi.insert(ch,i); &#125; koishi.calc(); return 0;&#125; 参考","categories":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://summercat7.github.io/categories/算法/"}]},{"title":"python数据分析","slug":"python","date":"2019-03-16T13:52:53.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/03/16/python/","link":"","permalink":"https://summercat7.github.io/2019/03/16/python/","excerpt":"","text":"《利用Python进行数据分析·第2版》Python利用sphinx构建个人博客使用Pelican和Github Pages搭建个人博客详细教程慕课网就业前端后端DjangoScrapy。。。","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"k-means图像分割","slug":"k-means图像分割","date":"2019-03-14T11:34:37.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/03/14/k-means图像分割/","link":"","permalink":"https://summercat7.github.io/2019/03/14/k-means图像分割/","excerpt":"","text":"实现原理：将图片的每个像素点进行K-means聚类，然后生成新的图片。 参考资料：PIL库基础、数字图像处理、视觉机器学习 代码如下：123456789101112131415161718192021222324import numpy as npimport PIL.Image as imagefrom sklearn.cluster import KMeansdef load_data(file_path): f = open(file_path,'rb') #二进制打开 data = [] img = image.open(f) #以列表形式返回图片像素值 m,n = img.size #活的图片大小 for i in range(m): for j in range(n): #将每个像素点RGB颜色处理到0-1范围内并存放data x,y,z = img.getpixel((i,j)) data.append([x/256.0,y/256.0,z/256.0]) f.close() return np.mat(data),m,n #以矩阵型式返回data，图片大小img_data,row,col = load_data('img.jpg')label = KMeans(n_clusters=2).fit_predict(img_data) #聚类中心的个数为3label = label.reshape([row,col]) #聚类获得每个像素所属的类别pic_new = image.new(\"L\",(row,col)) #创建一张新的灰度图保存聚类后的结果for i in range(row): #根据所属类别向图片中添加灰度值 for j in range(col): pic_new.putpixel((i,j),int(256/(label[i][j]+1)))pic_new.save('new_img.jpg') sublime 虚拟环境","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]},{"title":"python图片爬取","slug":"python图片爬取","date":"2019-03-10T15:06:11.000Z","updated":"2023-12-29T14:11:02.000Z","comments":true,"path":"2019/03/10/python图片爬取/","link":"","permalink":"https://summercat7.github.io/2019/03/10/python图片爬取/","excerpt":"","text":"主要功能：爬取京东商城手机销售页面的手机图片，将其下载到本地文件夹。 代码如下：12345678910111213141516171819202122import urllib.requestimport redef f(url,page): http = urllib.request.urlopen(url).read() #打开传入的页面 http = str(http) #将网页内容转换为str类型 obj = '&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//(.*?\\.jpg)\"&gt;' #正则表示图片所存的网址 #img = re.compile(obj).findall(http) img = re.findall(obj,http) #将http中符合正则表示的保存在img列表，上行有同样效果 index = 1 for i in img: s = 'http://' + index #将图片网址加上(http://)前缀使其可以访问 try: urllib.request.urlretrieve(s,\"./img/pic\"+str(page)+str(index)+\".jpg\") #(urlretrieve)可以将s下载到对应的目录 except urllib.request.URLError as e: pass else: index += 1for i in range(1,80): url = 'https://list.jd.com/list.html?cat=9987,653,655&amp;page=' + str(i) #前为京东手机选购的网址，page 为该网页的所在的页数 f(url,i)","categories":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://summercat7.github.io/categories/python/"}]}]}